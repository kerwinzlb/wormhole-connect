"use strict";var D=Object.defineProperty;var H=(o,e,t)=>e in o?D(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var p=(o,e,t)=>(H(o,typeof e!="symbol"?e+"":e,t),t);const n=require("./index-BMvV5qga.js"),l=require("./algorand-B47Qnita.js"),z=require("./create-C7G6iKS_.js"),$=require("./chain-DBb0uF1j.js");class K{constructor(e,t,r,s,i=!1){p(this,"transaction");p(this,"network");p(this,"chain");p(this,"description");p(this,"parallelizable");this.transaction=e,this.network=t,this.chain=r,this.description=s,this.parallelizable=i}}const V=1002e3,U=15,L=127,C=8,N=L*C,F=L*U,O=C*F,y={_limit:127,encodingLength:o=>{let e=0;for(;o>=128;e++)o>>=7;return e+1},encode:(o,e,t)=>{if(typeof o=="bigint"&&(o=l.safeBigIntToNumber(o)),o<0)throw new RangeError("value must be unsigned");const r=y.encodingLength(o);if(e=e||new ArrayBuffer(r),t=t||0,e.byteLength<t+r)throw new RangeError("the buffer is too small to encode the number at the offset");const s=new Uint8Array(e,t);let i=0;for(;y._limit<o;)s[i++]=o&y._limit|128,o>>=7;return s[i]=Number(o),s},decode:(o,e=0)=>{let t=0,r=0,s;do{if(s=o[e+r],s===void 0)throw new RangeError("offset out of range");t+=(s&y._limit)<<r*7,r++}while(128<=s);return t}},u={forMessageId:(o,e)=>{const t=n.decodeAddress(n.getApplicationAddress(o)).publicKey,r=e.emitter.toUniversalAddress().toUint8Array(),s=n.bignum.toBytes(BigInt(n.toChainId(e.chain)),2),i=n.bytes.concat(s,r);return u.fromData({appId:o,appAddress:t,idx:e.sequence/BigInt(O),address:i})},forWrappedAsset:(o,e)=>{if(n.isNative(e.address))throw new Error("native asset cannot be a wrapped asset");const t=n.decodeAddress(n.getApplicationAddress(o)).publicKey;return u.fromData({appId:o,appAddress:t,idx:BigInt(n.toChainId(e.chain)),address:e.address.toUniversalAddress().toUint8Array()})},forNativeAsset:(o,e)=>{const t=n.decodeAddress(n.getApplicationAddress(o)).publicKey;return u.fromData({appId:o,appAddress:t,idx:e,address:n.bytes.encode("native")})},forGuardianSet:(o,e)=>{const t=n.decodeAddress(n.getApplicationAddress(o)).publicKey;return u.fromData({appId:o,appAddress:t,idx:BigInt(e),address:n.bytes.encode("guardian")})},forEmitter:(o,e)=>{const t=n.decodeAddress(n.getApplicationAddress(o)).publicKey;return u.fromData({appId:o,appAddress:t,idx:0n,address:e})},_encode:o=>typeof o=="bigint"?[n.hex.encode(y.encode(o))]:[n.hex.encode(y.encode(o.length)),n.hex.encode(o)],fromData:o=>{const e=["0620010181",...u._encode(o.idx),"4880",...u._encode(o.address),"483110810612443119221244311881",...u._encode(o.appId),"1244312080",...u._encode(o.appAddress),"124431018100124431093203124431153203124422"],t=n.hex.decode(e.join(""));return new n.LogicSigAccount(t)},decodeLocalState:async(o,e,t)=>{let r;try{const a=await o.accountApplicationInformation(t,l.safeBigIntToNumber(e)).do();r=n.AccountApplicationResponse.from_obj_for_encoding(a).appLocalState}catch{return new Uint8Array}const s=n.b64.encode("meta");let i=new Map;for(const a of r.keyValue){if(a.key===s)continue;const g=n.b64.decode(a.key)[0],A=n.b64.decode(a.value.bytes);i.set(g,A)}const d=[];for(let a=0;a<U;a++)i.has(a)&&d.push(i.get(a));return n.bytes.concat(...d)},checkBitsSet:async(o,e,t,r)=>{let s=!1,i;const d=await o.accountInformation(t).do(),g=n.Account.from_obj_for_encoding(d).appsLocalState;if(g&&g.forEach(m=>{BigInt(m.id)===e&&(i=m.keyValue)}),(i==null?void 0:i.length)===0)return s;const A=BigInt(O),h=BigInt(8),b=r/A*A,x=l.safeBigIntToNumber(r-b),w=Math.floor(x/N),I=Math.floor((x-w*N)/8),_=n.b64.encode(n.bignum.toBytes(w,1));return i==null||i.forEach(m=>{if(m.key===_){const k=n.dist.Buffer.from(m.value.bytes,"base64"),S=1<<l.safeBigIntToNumber(r%h);s=(k[I]&S)!=0;return}}),s},storageAccountExists:async(o,e,t)=>{try{const r=await o.accountApplicationInformation(e,l.safeBigIntToNumber(t)).do();return Object.keys(r).length>0}catch{}return!1}},c=class c{constructor(e,t,r,s){p(this,"network");p(this,"chain");p(this,"connection");p(this,"contracts");p(this,"chainId");p(this,"coreAppId");p(this,"coreAppAddress");p(this,"tokenBridgeAppId");p(this,"tokenBridgeAppAddress");if(this.network=e,this.chain=t,this.connection=r,this.contracts=s,this.chainId=n.toChainId(t),!s.coreBridge)throw new Error(`Core contract address for chain ${t} not found`);const i=BigInt(s.coreBridge);if(this.coreAppId=i,this.coreAppAddress=n.getApplicationAddress(i),!s.tokenBridge)throw new Error(`TokenBridge contract address for chain ${t} not found`);const d=BigInt(s.tokenBridge);this.tokenBridgeAppId=d,this.tokenBridgeAppAddress=n.getApplicationAddress(d)}getGuardianSet(e){throw new Error("Method not implemented.")}async*verifyMessage(e,t,r){const s=new l.AlgorandAddress(e).toString(),i=await c.submitVAAHeader(this.connection,this.coreAppId,r??this.coreAppId,t,s);for(const d of i.txs)yield this.createUnsignedTx(d,"Core.verifyMessage")}static async fromRpc(e,t){const[r,s]=await l.AlgorandPlatform.chainFromRpc(e),i=t[s];if(i.network!==r)throw new Error(`Network mismatch: ${i.network} !== ${r}`);return new c(r,s,e,i.contracts)}async*publishMessage(e,t){const r=new l.AlgorandAddress(e),s=r.toString(),i=await this.connection.getTransactionParams().do(),d=u.forEmitter(this.coreAppId,r.toUint8Array()),{accounts:a,txs:g}=await c.maybeCreateStorageTx(this.connection,s,this.coreAppId,d,i);for(const h of g)yield this.createUnsignedTx(h,"Core.publishMessage",!0);const A=n.makeApplicationCallTxnFromObject({from:s,appIndex:l.safeBigIntToNumber(this.coreAppId),appArgs:[c.publishMessage,t,n.bignum.toBytes(0n,8)],accounts:a,onComplete:n.OnApplicationComplete.NoOpOC,suggestedParams:i});yield this.createUnsignedTx({tx:A},"Core.publishMessage",!0)}async getMessageFee(){var s;const e=await this.connection.getApplicationByID(l.safeBigIntToNumber(this.coreAppId)).do(),r=(s=n.Application.from_obj_for_encoding(e).params.globalState)==null?void 0:s.find(i=>i.key===c.feeKey);return r?BigInt(r.value.uint):0n}async getGuardianSetIndex(){throw new Error("Not implemented")}async parseTransaction(e){const t=await this.connection.pendingTransactionInformation(e).do(),r=n.PendingTransactionResponse.from_obj_for_encoding(t);return this.parseTx(r).map(s=>({chain:s.emitterChain,emitter:s.emitterAddress,sequence:s.sequence}))}async parseMessages(e){const t=await this.connection.pendingTransactionInformation(e).do(),r=n.PendingTransactionResponse.from_obj_for_encoding(t);return this.parseTx(r)}parseTx(e){const t=[];if(e.innerTxns&&e.innerTxns.length>0&&t.push(...e.innerTxns.flatMap(g=>this.parseTx(g))),BigInt(e.txn.txn.apid??0)!==this.coreAppId||!e.logs||e.logs.length===0)return t;const r=e.txn.txn.apaa??[];if(r.length!==3||!n.bytes.equals(new Uint8Array(r[0]),c.publishMessage))return t;const s=n.bignum.decode(e.logs[0]),i=new l.AlgorandAddress(e.txn.txn.snd).toUniversalAddress(),d=new Uint8Array(r[1]),a=n.bignum.decode(r[2]);return t.push(z.createVAA("Uint8Array",{emitterChain:this.chain,emitterAddress:i,sequence:s,guardianSet:0,timestamp:0,consistencyLevel:0,nonce:Number(a),payload:d,signatures:[]})),t}static async maybeCreateStorageTx(e,t,r,s,i){const d=n.getApplicationAddress(r),a=s.address(),g=[];if(await u.storageAccountExists(e,a,r))return{accounts:[a],txs:g};i=i??await e.getTransactionParams().do();const A=n.makePaymentTxnWithSuggestedParamsFromObject({from:t,to:a,amount:V,suggestedParams:i});A.fee=A.fee*2,g.push({tx:A});const h=n.makeApplicationOptInTxnFromObject({from:a,appIndex:l.safeBigIntToNumber(r),rekeyTo:d,suggestedParams:i});return h.fee=0,g.push({tx:h,signer:{address:s.address(),signTxn:b=>Promise.resolve(n.signLogicSigTransaction(b,s).blob)}}),{accounts:[a],txs:g}}static async submitVAAHeader(e,t,r,s,i,d){d=d??await e.getTransactionParams().do();let a=[];const g=u.forMessageId(r,{chain:s.emitterChain,sequence:s.sequence,emitter:s.emitterAddress}),{accounts:A,txs:h}=await c.maybeCreateStorageTx(e,i,r,g,d);a.push(...h);const b=u.forGuardianSet(t,s.guardianSet),{accounts:[x],txs:w}=await c.maybeCreateStorageTx(e,i,t,b,d);a.push(...w);let I=[...A,x];const _=await u.decodeLocalState(e,t,x),m=n.keccak_256(s.hash),k=s.signatures.length,S=Math.ceil(k/c.MAX_SIGS_PER_TXN),E=20,v=new n.LogicSigAccount(c.ALGO_VERIFY);for(let R=0;R<S;R++){const G=R*c.MAX_SIGS_PER_TXN,B=s.signatures.slice(G,G+c.MAX_SIGS_PER_TXN),Y=B.length*E,X=new Uint8Array(Y);for(let f=0;f<B.length;f++){const j=B[f],q=_.slice(j.guardianIndex*E+1,(j.guardianIndex+1)*E+1);X.set(q,f*20)}const P=n.makeApplicationCallTxnFromObject({appArgs:[c.verifySigs,n.bytes.concat(...B.map(f=>n.bytes.concat(new Uint8Array([f.guardianIndex]),f.signature.encode()))),X,m],accounts:I,appIndex:l.safeBigIntToNumber(t),from:c.ALGO_VERIFY_HASH,onComplete:n.OnApplicationComplete.NoOpOC,suggestedParams:d});P.fee=0,a.push({tx:P,signer:{address:v.address(),signTxn:f=>Promise.resolve(n.signLogicSigTransaction(f,v).blob)}})}const M=n.makeApplicationCallTxnFromObject({appArgs:[c.verifyVaa,n.serialize(s)],accounts:I,appIndex:l.safeBigIntToNumber(t),from:i,onComplete:n.OnApplicationComplete.NoOpOC,suggestedParams:d});return M.fee=M.fee*(2+S),a.push({tx:M}),{accounts:I,txs:a}}createUnsignedTx(e,t,r=!0){return new K(e,this.network,this.chain,t,r)}};p(c,"MAX_SIGS_PER_TXN",6),p(c,"ALGO_VERIFY_HASH","EZATROXX2HISIRZDRGXW4LRQ46Z6IUJYYIHU3PJGP7P5IQDPKVX42N767A"),p(c,"ALGO_VERIFY",new Uint8Array([6,32,4,1,0,32,20,38,1,0,49,32,50,3,18,68,49,1,35,18,68,49,16,129,6,18,68,54,26,1,54,26,3,54,26,2,136,0,3,68,34,67,53,2,53,1,53,0,40,53,240,40,53,241,52,0,21,53,5,35,53,3,35,53,4,52,3,52,5,12,65,0,68,52,1,52,0,52,3,129,65,8,34,88,23,52,0,52,3,34,8,36,88,52,0,52,3,129,33,8,36,88,7,0,53,241,53,240,52,2,52,4,37,88,52,240,52,241,80,2,87,12,20,18,68,52,3,129,66,8,53,3,52,4,37,8,53,4,66,255,180,34,137])),p(c,"feeKey",n.b64.encode("MessageFee")),p(c,"verifyVaa",n.bytes.encode("verifyVAA")),p(c,"verifySigs",n.bytes.encode("verifySigs")),p(c,"publishMessage",n.bytes.encode("publishMessage"));let T=c;$.registerProtocol("Algorand","WormholeCore",T);const Z=Object.freeze(Object.defineProperty({__proto__:null,AlgorandWormholeCore:T,BITS_PER_BYTE:C,BITS_PER_KEY:N,MAX_BITS:O,MAX_BYTES:F,MAX_BYTES_PER_KEY:L,MAX_KEYS:U,SEED_AMT:V,StorageLogicSig:u,varint:y},Symbol.toStringTag,{value:"Module"}));exports.AlgorandUnsignedTransaction=K;exports.AlgorandWormholeCore=T;exports.StorageLogicSig=u;exports.index=Z;

"use strict";var qt=Object.defineProperty;var Ft=(i,e,t)=>e in i?qt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var q=(i,e,t)=>(Ft(i,typeof e!="symbol"?e+"":e,t),t);const a=require("./index-BMvV5qga.js"),it=require("./chain-DBb0uF1j.js");class Ot extends TypeError{constructor(e,t){let n;const{message:s,...r}=e,{path:o}=e,c=o.length===0?s:"At path: "+o.join(".")+" -- "+s;super(c),Object.assign(this,r),this.name=this.constructor.name,this.failures=()=>{var u;return(u=n)!=null?u:n=[e,...t()]}}}function Ut(i){return Y(i)&&typeof i[Symbol.iterator]=="function"}function Y(i){return typeof i=="object"&&i!=null}function W(i){return typeof i=="string"?JSON.stringify(i):""+i}function Mt(i){const{done:e,value:t}=i.next();return e?void 0:t}function zt(i,e,t,n){if(i===!0)return;i===!1?i={}:typeof i=="string"&&(i={message:i});const{path:s,branch:r}=e,{type:o}=t,{refinement:c,message:u="Expected a value of type `"+o+"`"+(c?" with refinement `"+c+"`":"")+", but received: `"+W(n)+"`"}=i;return{value:n,type:o,refinement:c,key:s[s.length-1],path:s,branch:r,...i,message:u}}function*Xe(i,e,t,n){Ut(i)||(i=[i]);for(const s of i){const r=zt(s,e,t,n);r&&(yield r)}}function*ze(i,e,t={}){const{path:n=[],branch:s=[i],coerce:r=!1,mask:o=!1}=t,c={path:n,branch:s};if(r&&(i=e.coercer(i,c),o&&e.type!=="type"&&Y(e.schema)&&Y(i)&&!Array.isArray(i)))for(const d in i)e.schema[d]===void 0&&delete i[d];let u=!0;for(const d of e.validator(i,c))u=!1,yield[d,void 0];for(let[d,f,S]of e.entries(i,c)){const R=ze(f,S,{path:d===void 0?n:[...n,d],branch:d===void 0?s:[...s,f],coerce:r,mask:o});for(const w of R)w[0]?(u=!1,yield[w[0],void 0]):r&&(f=w[1],d===void 0?i=f:i instanceof Map?i.set(d,f):i instanceof Set?i.add(f):Y(i)&&(i[d]=f))}if(u)for(const d of e.refiner(i,c))u=!1,yield[d,void 0];u&&(yield[void 0,i])}let H=class{constructor(e){const{type:t,schema:n,validator:s,refiner:r,coercer:o=u=>u,entries:c=function*(){}}=e;this.type=t,this.schema=n,this.entries=c,this.coercer=o,s?this.validator=(u,d)=>{const f=s(u,d);return Xe(f,d,this,u)}:this.validator=()=>[],r?this.refiner=(u,d)=>{const f=r(u,d);return Xe(f,d,this,u)}:this.refiner=()=>[]}assert(e){return Wt(e,this)}create(e){return m(e,this)}is(e){return at(e,this)}mask(e){return Dt(e,this)}validate(e,t={}){return be(e,this,t)}};function Wt(i,e){const t=be(i,e);if(t[0])throw t[0]}function m(i,e){const t=be(i,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Dt(i,e){const t=be(i,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function at(i,e){return!be(i,e)[0]}function be(i,e,t={}){const n=ze(i,e,t),s=Mt(n);return s[0]?[new Ot(s[0],function*(){for(const o of n)o[0]&&(yield o[0])}),void 0]:[void 0,s[1]]}function re(i,e){return new H({type:i,schema:null,validator:e})}function Ht(){return re("any",()=>!0)}function k(i){return new H({type:"array",schema:i,*entries(e){if(i&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,i]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+W(e)}})}function D(){return re("boolean",i=>typeof i=="boolean")}function We(i){return re("instance",e=>e instanceof i||"Expected a `"+i.name+"` instance, but received: "+W(e))}function C(i){const e=W(i),t=typeof i;return new H({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?i:null,validator(n){return n===i||"Expected the literal `"+e+"`, but received: "+W(n)}})}function Gt(){return re("never",()=>!1)}function b(i){return new H({...i,validator:(e,t)=>e===null||i.validator(e,t),refiner:(e,t)=>e===null||i.refiner(e,t)})}function l(){return re("number",i=>typeof i=="number"&&!isNaN(i)||"Expected a number, but received: "+W(i))}function B(i){return new H({...i,validator:(e,t)=>e===void 0||i.validator(e,t),refiner:(e,t)=>e===void 0||i.refiner(e,t)})}function ct(i,e){return new H({type:"record",schema:null,*entries(t){if(Y(t))for(const n in t){const s=t[n];yield[n,n,i],yield[n,s,e]}},validator(t){return Y(t)||"Expected an object, but received: "+W(t)}})}function p(){return re("string",i=>typeof i=="string"||"Expected a string, but received: "+W(i))}function De(i){const e=Gt();return new H({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(i.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],i[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+W(t)}})}function h(i){const e=Object.keys(i);return new H({type:"type",schema:i,*entries(t){if(Y(t))for(const n of e)yield[n,t[n],i[n]]},validator(t){return Y(t)||"Expected an object, but received: "+W(t)}})}function F(i){const e=i.map(t=>t.type).join(" | ");return new H({type:"union",schema:null,validator(t,n){const s=[];for(const r of i){const[...o]=ze(t,r,n),[c]=o;if(c[0])for(const[u]of o)u&&s.push(u);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+W(t),...s]}})}function we(){return re("unknown",()=>!0)}function ke(i,e,t){return new H({...i,coercer:(n,s)=>at(n,e)?i.coercer(t(n,s),s):i.coercer(n,s)})}const Ye=()=>{const i=a.ed25519.utils.randomPrivateKey(),e=Ke(i),t=new Uint8Array(64);return t.set(i),t.set(e,32),{publicKey:e,secretKey:t}},Ke=a.ed25519.getPublicKey;function Ze(i){try{return a.ed25519.ExtendedPoint.fromHex(i),!0}catch{return!1}}const $t=(i,e)=>a.ed25519.sign(i,e.slice(0,32)),jt=a.ed25519.verify,se=i=>a.bufferPolyfill.Buffer.isBuffer(i)?i:i instanceof Uint8Array?a.bufferPolyfill.Buffer.from(i.buffer,i.byteOffset,i.byteLength):a.bufferPolyfill.Buffer.from(i);class Vt{constructor(e){Object.assign(this,e)}encode(){return a.bufferPolyfill.Buffer.from(a.serialize_1(Re,this))}static decode(e){return a.deserialize_1(Re,this,e)}static decodeUnchecked(e){return a.deserializeUnchecked_1(Re,this,e)}}const Re=new Map;var ut;let lt;const Jt=32,Z=32;function Xt(i){return i._bn!==void 0}let Qe=1;lt=Symbol.toStringTag;class A extends Vt{constructor(e){if(super({}),this._bn=void 0,Xt(e))this._bn=e._bn;else{if(typeof e=="string"){const t=a.bs58.decode(e);if(t.length!=Z)throw new Error("Invalid public key input");this._bn=new a.BN(t)}else this._bn=new a.BN(e);if(this._bn.byteLength()>Z)throw new Error("Invalid public key input")}}static unique(){const e=new A(Qe);return Qe+=1,new A(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return a.bs58.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(a.bufferPolyfill.Buffer);if(e.length===Z)return e;const t=a.bufferPolyfill.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[lt](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=a.bufferPolyfill.Buffer.concat([e.toBuffer(),a.bufferPolyfill.Buffer.from(t),n.toBuffer()]),r=a.sha256(s);return new A(r)}static createProgramAddressSync(e,t){let n=a.bufferPolyfill.Buffer.alloc(0);e.forEach(function(r){if(r.length>Jt)throw new TypeError("Max seed length exceeded");n=a.bufferPolyfill.Buffer.concat([n,se(r)])}),n=a.bufferPolyfill.Buffer.concat([n,t.toBuffer(),a.bufferPolyfill.Buffer.from("ProgramDerivedAddress")]);const s=a.sha256(n);if(Ze(s))throw new Error("Invalid seeds, address must fall off the curve");return new A(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const r=e.concat(a.bufferPolyfill.Buffer.from([n]));s=this.createProgramAddressSync(r,t)}catch(r){if(r instanceof TypeError)throw r;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new A(e);return Ze(t.toBytes())}}ut=A;A.default=new ut("11111111111111111111111111111111");Re.set(A,{kind:"struct",fields:[["_bn","u256"]]});new A("BPFLoader1111111111111111111111111111111111");const ue=1232,dt=127,ht=64;class He extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(He.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class ft extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ft.prototype,"name",{value:"TransactionExpiredTimeoutError"});class fe extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(fe.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Be{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((r,o)=>{n.set(r.toBase58(),o)});const s=r=>{const o=n.get(r.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return e.map(r=>({programIdIndex:s(r.programId),accountKeyIndexes:r.keys.map(o=>s(o.pubkey)),data:r.data}))}}const x=(i="publicKey")=>a.blob(32,i),ce=(i="string")=>{const e=a.struct([a.u32("length"),a.u32("lengthPadding"),a.blob(a.offset(a.u32(),-8),"chars")],i),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(r,o)=>t(r,o).chars.toString(),s.encode=(r,o,c)=>{const u={chars:a.bufferPolyfill.Buffer.from(r,"utf8")};return n(u,o,c)},s.alloc=r=>a.u32().span+a.u32().span+a.bufferPolyfill.Buffer.from(r,"utf8").length,s},Yt=(i="authorized")=>a.struct([x("staker"),x("withdrawer")],i),Zt=(i="lockup")=>a.struct([a.ns64("unixTimestamp"),a.ns64("epoch"),x("custodian")],i),Qt=(i="voteInit")=>a.struct([x("nodePubkey"),x("authorizedVoter"),x("authorizedWithdrawer"),a.u8("commission")],i),en=(i="voteAuthorizeWithSeedArgs")=>a.struct([a.u32("voteAuthorizationType"),x("currentAuthorityDerivedKeyOwnerPubkey"),ce("currentAuthorityDerivedKeySeed"),x("newAuthorized")],i);function gt(i,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const r=e[s.property];if(Array.isArray(r))return r.length*t(s.elementLayout)}else if("fields"in s)return gt({layout:s},e[s.property]);return 0};let n=0;return i.layout.fields.forEach(s=>{n+=t(s)}),n}function O(i){let e=0,t=0;for(;;){let n=i.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function U(i,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){i.push(n);break}else n|=128,i.push(n)}}function L(i,e){if(!i)throw new Error(e||"Assertion failed")}class Te{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=o=>{const c=o.toBase58();let u=n.get(c);return u===void 0&&(u={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(c,u)),u},r=s(t);r.isSigner=!0,r.isWritable=!0;for(const o of e){s(o.programId).isInvoked=!0;for(const c of o.keys){const u=s(c.pubkey);u.isSigner||(u.isSigner=c.isSigner),u.isWritable||(u.isWritable=c.isWritable)}}return new Te(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];L(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,u])=>u.isSigner&&u.isWritable),n=e.filter(([,u])=>u.isSigner&&!u.isWritable),s=e.filter(([,u])=>!u.isSigner&&u.isWritable),r=e.filter(([,u])=>!u.isSigner&&!u.isWritable),o={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:r.length};{L(t.length>0,"Expected at least one writable signer key");const[u]=t[0];L(u===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const c=[...t.map(([u])=>new A(u)),...n.map(([u])=>new A(u)),...s.map(([u])=>new A(u)),...r.map(([u])=>new A(u))];return[o,c]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[s,r]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:r}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[r,o]of this.keyMetaMap.entries())if(t(o)){const c=new A(r),u=e.findIndex(d=>d.equals(c));u>=0&&(L(u<256,"Max lookup table index exceeded"),n.push(u),s.push(c),this.keyMetaMap.delete(r))}return[n,s]}}const pt="Reached end of buffer unexpectedly";function $(i){if(i.length===0)throw new Error(pt);return i.shift()}function M(i,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>i.length:t>=i.length)throw new Error(pt);return i.splice(...e)}class j{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new A(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:a.bs58.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Be(this.staticAccountKeys)}static compile(e){const t=Te.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),o=new Be(s).compileInstructions(e.instructions).map(c=>({programIdIndex:c.programIdIndex,accounts:c.accountKeyIndexes,data:a.bs58.encode(c.data)}));return new j({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:o})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,r=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<r}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];U(t,e);const n=this.instructions.map(S=>{const{accounts:R,programIdIndex:w}=S,y=Array.from(a.bs58.decode(S.data));let g=[];U(g,R.length);let _=[];return U(_,y.length),{programIdIndex:w,keyIndicesCount:a.bufferPolyfill.Buffer.from(g),keyIndices:R,dataLength:a.bufferPolyfill.Buffer.from(_),data:y}});let s=[];U(s,n.length);let r=a.bufferPolyfill.Buffer.alloc(ue);a.bufferPolyfill.Buffer.from(s).copy(r);let o=s.length;n.forEach(S=>{const w=a.struct([a.u8("programIdIndex"),a.blob(S.keyIndicesCount.length,"keyIndicesCount"),a.seq(a.u8("keyIndex"),S.keyIndices.length,"keyIndices"),a.blob(S.dataLength.length,"dataLength"),a.seq(a.u8("userdatum"),S.data.length,"data")]).encode(S,r,o);o+=w}),r=r.slice(0,o);const c=a.struct([a.blob(1,"numRequiredSignatures"),a.blob(1,"numReadonlySignedAccounts"),a.blob(1,"numReadonlyUnsignedAccounts"),a.blob(t.length,"keyCount"),a.seq(x("key"),e,"keys"),x("recentBlockhash")]),u={numRequiredSignatures:a.bufferPolyfill.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:a.bufferPolyfill.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:a.bufferPolyfill.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:a.bufferPolyfill.Buffer.from(t),keys:this.accountKeys.map(S=>se(S.toBytes())),recentBlockhash:a.bs58.decode(this.recentBlockhash)};let d=a.bufferPolyfill.Buffer.alloc(2048);const f=c.encode(u,d);return r.copy(d,f),d.slice(0,f+r.length)}static from(e){let t=[...e];const n=$(t);if(n!==(n&dt))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=$(t),r=$(t),o=O(t);let c=[];for(let R=0;R<o;R++){const w=M(t,0,Z);c.push(new A(a.bufferPolyfill.Buffer.from(w)))}const u=M(t,0,Z),d=O(t);let f=[];for(let R=0;R<d;R++){const w=$(t),y=O(t),g=M(t,0,y),_=O(t),E=M(t,0,_),K=a.bs58.encode(a.bufferPolyfill.Buffer.from(E));f.push({programIdIndex:w,accounts:g,data:K})}const S={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:r},recentBlockhash:a.bs58.encode(a.bufferPolyfill.Buffer.from(u)),accountKeys:c,instructions:f};return new j(S)}}class me{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Be(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,r=this.addressTableLookups.reduce((o,c)=>o+c.writableIndexes.length,0);return s<r}else if(e>=this.header.numRequiredSignatures){const s=e-t,o=n-t-this.header.numReadonlyUnsignedAccounts;return s<o}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(r=>r.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const r of n.writableIndexes)if(r<s.state.addresses.length)t.writable.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`);for(const r of n.readonlyIndexes)if(r<s.state.addresses.length)t.readonly.push(s.state.addresses[r]);else throw new Error(`Failed to find address for index ${r} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Te.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},r=e.addressLookupTableAccounts||[];for(const f of r){const S=t.extractTableLookup(f);if(S!==void 0){const[R,{writable:w,readonly:y}]=S;n.push(R),s.writable.push(...w),s.readonly.push(...y)}}const[o,c]=t.getMessageComponents(),d=new Be(c,s).compileInstructions(e.instructions);return new me({header:o,staticAccountKeys:c,recentBlockhash:e.recentBlockhash,compiledInstructions:d,addressTableLookups:n})}serialize(){const e=Array();U(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();U(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),r=Array();U(r,this.addressTableLookups.length);const o=a.struct([a.u8("prefix"),a.struct([a.u8("numRequiredSignatures"),a.u8("numReadonlySignedAccounts"),a.u8("numReadonlyUnsignedAccounts")],"header"),a.blob(e.length,"staticAccountKeysLength"),a.seq(x(),this.staticAccountKeys.length,"staticAccountKeys"),x("recentBlockhash"),a.blob(n.length,"instructionsLength"),a.blob(t.length,"serializedInstructions"),a.blob(r.length,"addressTableLookupsLength"),a.blob(s.length,"serializedAddressTableLookups")]),c=new Uint8Array(ue),d=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(f=>f.toBytes()),recentBlockhash:a.bs58.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(r),serializedAddressTableLookups:s},c);return c.slice(0,d)}serializeInstructions(){let e=0;const t=new Uint8Array(ue);for(const n of this.compiledInstructions){const s=Array();U(s,n.accountKeyIndexes.length);const r=Array();U(r,n.data.length);const o=a.struct([a.u8("programIdIndex"),a.blob(s.length,"encodedAccountKeyIndexesLength"),a.seq(a.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),a.blob(r.length,"encodedDataLength"),a.blob(n.data.length,"data")]);e+=o.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(r),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(ue);for(const n of this.addressTableLookups){const s=Array();U(s,n.writableIndexes.length);const r=Array();U(r,n.readonlyIndexes.length);const o=a.struct([x("accountKey"),a.blob(s.length,"encodedWritableIndexesLength"),a.seq(a.u8(),n.writableIndexes.length,"writableIndexes"),a.blob(r.length,"encodedReadonlyIndexesLength"),a.seq(a.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=o.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(r),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=$(t),s=n&dt;L(n!==s,"Expected versioned message but received legacy message");const r=s;L(r===0,`Expected versioned message with version 0 but found version ${r}`);const o={numRequiredSignatures:$(t),numReadonlySignedAccounts:$(t),numReadonlyUnsignedAccounts:$(t)},c=[],u=O(t);for(let y=0;y<u;y++)c.push(new A(M(t,0,Z)));const d=a.bs58.encode(M(t,0,Z)),f=O(t),S=[];for(let y=0;y<f;y++){const g=$(t),_=O(t),E=M(t,0,_),K=O(t),ee=new Uint8Array(M(t,0,K));S.push({programIdIndex:g,accountKeyIndexes:E,data:ee})}const R=O(t),w=[];for(let y=0;y<R;y++){const g=new A(M(t,0,Z)),_=O(t),E=M(t,0,_),K=O(t),ee=M(t,0,K);w.push({accountKey:g,writableIndexes:E,readonlyIndexes:ee})}return new me({header:o,staticAccountKeys:c,recentBlockhash:d,compiledInstructions:S,addressTableLookups:w})}}let J=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({});const tn=a.bufferPolyfill.Buffer.alloc(ht).fill(0);class ne{constructor(e){this.keys=void 0,this.programId=void 0,this.data=a.bufferPolyfill.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class X{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new ne(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let g=0;g<t.length;g++)if(t[g].programId===void 0)throw new Error(`Transaction instruction index ${g} has undefined program id`);const s=[],r=[];t.forEach(g=>{g.keys.forEach(E=>{r.push({...E})});const _=g.programId.toString();s.includes(_)||s.push(_)}),s.forEach(g=>{r.push({pubkey:new A(g),isSigner:!1,isWritable:!1})});const o=[];r.forEach(g=>{const _=g.pubkey.toString(),E=o.findIndex(K=>K.pubkey.toString()===_);E>-1?(o[E].isWritable=o[E].isWritable||g.isWritable,o[E].isSigner=o[E].isSigner||g.isSigner):o.push(g)}),o.sort(function(g,_){if(g.isSigner!==_.isSigner)return g.isSigner?-1:1;if(g.isWritable!==_.isWritable)return g.isWritable?-1:1;const E={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return g.pubkey.toBase58().localeCompare(_.pubkey.toBase58(),"en",E)});const c=o.findIndex(g=>g.pubkey.equals(n));if(c>-1){const[g]=o.splice(c,1);g.isSigner=!0,g.isWritable=!0,o.unshift(g)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const g of this.signatures){const _=o.findIndex(E=>E.pubkey.equals(g.publicKey));if(_>-1)o[_].isSigner||(o[_].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${g.publicKey.toString()}`)}let u=0,d=0,f=0;const S=[],R=[];o.forEach(({pubkey:g,isSigner:_,isWritable:E})=>{_?(S.push(g.toString()),u+=1,E||(d+=1)):(R.push(g.toString()),E||(f+=1))});const w=S.concat(R),y=t.map(g=>{const{data:_,programId:E}=g;return{programIdIndex:w.indexOf(E.toString()),accounts:g.keys.map(K=>w.indexOf(K.pubkey.toString())),data:a.bs58.encode(_)}});return y.forEach(g=>{L(g.programIdIndex>=0),g.accounts.forEach(_=>L(_>=0))}),new j({header:{numRequiredSignatures:u,numReadonlySignedAccounts:d,numReadonlyUnsignedAccounts:f},accountKeys:w,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,r)=>t[r].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}this.signatures=n.map(r=>({signature:null,publicKey:r.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const r of e){const o=r.publicKey.toString();t.has(o)||(t.add(o),n.push(r))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const r=$t(n,s.secretKey);this._addSignature(s.publicKey,se(r))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){L(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=a.bufferPolyfill.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:r}of this.signatures)s===null?t&&(n.missing||(n.missing=[])).push(r):jt(s,e,r.toBytes())||(n.invalid||(n.invalid=[])).push(r);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const r=this._getMessageSignednessErrors(s,t);if(r){let o="Signature verification failed.";throw r.invalid&&(o+=`
Invalid signature for public key${r.invalid.length===1?"":"(s)"} [\`${r.invalid.map(c=>c.toBase58()).join("`, `")}\`].`),r.missing&&(o+=`
Missing signature for public key${r.missing.length===1?"":"(s)"} [\`${r.missing.map(c=>c.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];U(n,t.length);const s=n.length+t.length*64+e.length,r=a.bufferPolyfill.Buffer.alloc(s);return L(t.length<256),a.bufferPolyfill.Buffer.from(n).copy(r,0),t.forEach(({signature:o},c)=>{o!==null&&(L(o.length===64,"signature has invalid length"),a.bufferPolyfill.Buffer.from(o).copy(r,n.length+c*64))}),e.copy(r,n.length+t.length*64),L(r.length<=ue,`Transaction too large: ${r.length} > ${ue}`),r}get keys(){return L(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return L(this.instructions.length===1),this.instructions[0].programId}get data(){return L(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=O(t);let s=[];for(let r=0;r<n;r++){const o=M(t,0,ht);s.push(a.bs58.encode(a.bufferPolyfill.Buffer.from(o)))}return X.populate(j.from(t),s)}static populate(e,t=[]){const n=new X;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,r)=>{const o={signature:s==a.bs58.encode(tn)?null:a.bs58.decode(s),publicKey:e.accountKeys[r]};n.signatures.push(o)}),e.instructions.forEach(s=>{const r=s.accounts.map(o=>{const c=e.accountKeys[o];return{pubkey:c,isSigner:n.signatures.some(u=>u.publicKey.toString()===c.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});n.instructions.push(new ne({keys:r,programId:e.accountKeys[s.programIdIndex],data:a.bs58.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}class Ge{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:s,recentBlockhash:r}=e,{numRequiredSignatures:o,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u}=n,d=o-c;L(d>0,"Message header is invalid");const f=e.staticAccountKeys.length-o-u;L(f>=0,"Message header is invalid");const S=e.getAccountKeys(t),R=S.get(0);if(R===void 0)throw new Error("Failed to decompile message because no account keys were found");const w=[];for(const y of s){const g=[];for(const E of y.accountKeyIndexes){const K=S.get(E);if(K===void 0)throw new Error(`Failed to find key for account key index ${E}`);const ee=E<o;let V;ee?V=E<d:E<S.staticAccountKeys.length?V=E-o<f:V=E-S.staticAccountKeys.length<S.accountKeysFromLookups.writable.length,g.push({pubkey:K,isSigner:E<n.numRequiredSignatures,isWritable:V})}const _=S.get(y.programIdIndex);if(_===void 0)throw new Error(`Failed to find program id for program id index ${y.programIdIndex}`);w.push(new ne({programId:_,data:se(y.data),keys:g}))}return new Ge({payerKey:R,instructions:w,recentBlockhash:r})}compileToLegacyMessage(){return j.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return me.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}const nn=160,sn=64,rn=nn/sn,on=1e3/rn;new A("SysvarC1ock11111111111111111111111111111111");new A("SysvarEpochSchedu1e111111111111111111111111");new A("Sysvar1nstructions1111111111111111111111111");new A("SysvarRecentB1ockHashes11111111111111111111");new A("SysvarRent111111111111111111111111111111111");new A("SysvarRewards111111111111111111111111111111");new A("SysvarS1otHashes111111111111111111111111111");new A("SysvarS1otHistory11111111111111111111111111");new A("SysvarStakeHistory1111111111111111111111111");function ae(i){return new Promise(e=>setTimeout(e,i))}function _e(i,e){const t=i.layout.span>=0?i.layout.span:gt(i,e),n=a.bufferPolyfill.Buffer.alloc(t),s=Object.assign({instruction:i.index},e);return i.layout.encode(s,n),n}const an=a.nu64("lamportsPerSignature"),mt=a.struct([a.u32("version"),a.u32("state"),x("authorizedPubkey"),x("nonce"),a.struct([an],"feeCalculator")]);mt.span;class $e{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=mt.decode(se(e),0);return new $e({authorizedPubkey:new A(t.authorizedPubkey),nonce:new A(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const cn=i=>{const e=i.decode.bind(i),t=i.encode.bind(i);return{decode:e,encode:t}},un=i=>e=>{const t=a.blob(i,e),{encode:n,decode:s}=cn(t),r=t;return r.decode=(o,c)=>{const u=s(o,c);return a.toBigIntLE_1(a.bufferPolyfill.Buffer.from(u))},r.encode=(o,c,u)=>{const d=a.toBufferLE_1(o,i);return n(d,c,u)},r},le=un(8);Object.freeze({Create:{index:0,layout:a.struct([a.u32("instruction"),a.ns64("lamports"),a.ns64("space"),x("programId")])},Assign:{index:1,layout:a.struct([a.u32("instruction"),x("programId")])},Transfer:{index:2,layout:a.struct([a.u32("instruction"),le("lamports")])},CreateWithSeed:{index:3,layout:a.struct([a.u32("instruction"),x("base"),ce("seed"),a.ns64("lamports"),a.ns64("space"),x("programId")])},AdvanceNonceAccount:{index:4,layout:a.struct([a.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:a.struct([a.u32("instruction"),x("authorized")])},AuthorizeNonceAccount:{index:7,layout:a.struct([a.u32("instruction"),x("authorized")])},Allocate:{index:8,layout:a.struct([a.u32("instruction"),a.ns64("space")])},AllocateWithSeed:{index:9,layout:a.struct([a.u32("instruction"),x("base"),ce("seed"),a.ns64("space"),x("programId")])},AssignWithSeed:{index:10,layout:a.struct([a.u32("instruction"),x("base"),ce("seed"),x("programId")])},TransferWithSeed:{index:11,layout:a.struct([a.u32("instruction"),le("lamports"),ce("seed"),x("programId")])},UpgradeNonceAccount:{index:12,layout:a.struct([a.u32("instruction")])}});new A("11111111111111111111111111111111");new A("BPFLoader2111111111111111111111111111111111");function ln(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var dn=Object.prototype.toString,hn=Object.keys||function(i){var e=[];for(var t in i)e.push(t);return e};function ge(i,e){var t,n,s,r,o,c,u;if(i===!0)return"true";if(i===!1)return"false";switch(typeof i){case"object":if(i===null)return null;if(i.toJSON&&typeof i.toJSON=="function")return ge(i.toJSON(),e);if(u=dn.call(i),u==="[object Array]"){for(s="[",n=i.length-1,t=0;t<n;t++)s+=ge(i[t],!0)+",";return n>-1&&(s+=ge(i[t],!0)),s+"]"}else if(u==="[object Object]"){for(r=hn(i).sort(),n=r.length,s="",t=0;t<n;)o=r[t],c=ge(i[o],!1),c!==void 0&&(s&&(s+=","),s+=JSON.stringify(o)+":"+c),t++;return"{"+s+"}"}else return JSON.stringify(i);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(i);default:return isFinite(i)?i:null}}var fn=function(i){var e=ge(i,!1);if(e!==void 0)return""+e},et=ln(fn);const he=32;function Pe(i){let e=0;for(;i>1;)i/=2,e++;return e}function gn(i){return i===0?1:(i--,i|=i>>1,i|=i>>2,i|=i>>4,i|=i>>8,i|=i>>16,i|=i>>32,i+1)}class pn{constructor(e,t,n,s,r){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=r}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Pe(gn(e+he+1))-Pe(he)-1,n=this.getSlotsInEpoch(t),s=e-(n-he);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,r=t%this.slotsPerEpoch;return[s,r]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*he:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Pe(he)):this.slotsPerEpoch}}class qe extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class I extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var mn=globalThis.fetch;class yn extends a._default{constructor(e,t,n){const s=r=>{const o=a._default$1(r,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function bn(i,e){let t;try{t=i.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==i.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);return t}const tt=56;class nt{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=bn(wn,e),n=e.length-tt;L(n>=0,"lookup table is invalid"),L(n%32===0,"lookup table is invalid");const s=n/32,{addresses:r}=a.struct([a.seq(x(),s,"addresses")]).decode(e.slice(tt));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new A(t.authority[0]):void 0,addresses:r.map(o=>new A(o))}}}const wn={index:1,layout:a.struct([a.u32("typeIndex"),le("deactivationSlot"),a.nu64("lastExtendedSlot"),a.u8("lastExtendedStartIndex"),a.u8(),a.seq(x(),a.offset(a.u8(),-1),"authority")])},kn=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Sn(i){const e=i.match(kn);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${i}\``);const[t,n,s,r]=e,o=i.startsWith("https:")?"wss:":"ws:",c=s==null?null:parseInt(s.slice(1),10),u=c==null?"":`:${c+1}`;return`${o}//${n}${u}${r}`}const N=ke(We(A),p(),i=>new A(i)),yt=De([p(),C("base64")]),je=ke(We(a.bufferPolyfill.Buffer),yt,i=>a.bufferPolyfill.Buffer.from(i[0],"base64")),_n=30*1e3;function An(i){if(/^https?:/.test(i)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return i}function v(i){let e,t;if(typeof i=="string")e=i;else if(i){const{commitment:n,...s}=i;e=n,t=s}return{commitment:e,config:t}}function bt(i){return F([h({jsonrpc:C("2.0"),id:p(),result:i}),h({jsonrpc:C("2.0"),id:p(),error:h({code:we(),message:p(),data:B(Ht())})})])}const In=bt(we());function T(i){return ke(bt(i),In,e=>"error"in e?e:{...e,result:m(e.result,i)})}function P(i){return T(h({context:h({slot:l()}),value:i}))}function xe(i){return h({context:h({slot:l()}),value:i})}function Le(i,e){return i===0?new me({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new A(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:a.bs58.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new j(e)}const Rn=h({foundation:l(),foundationTerm:l(),initial:l(),taper:l(),terminal:l()}),Bn=T(k(b(h({epoch:l(),effectiveSlot:l(),amount:l(),postBalance:l(),commission:B(b(l()))})))),En=k(h({slot:l(),prioritizationFee:l()})),Tn=h({total:l(),validator:l(),foundation:l(),epoch:l()}),xn=h({epoch:l(),slotIndex:l(),slotsInEpoch:l(),absoluteSlot:l(),blockHeight:B(l()),transactionCount:B(l())}),vn=h({slotsPerEpoch:l(),leaderScheduleSlotOffset:l(),warmup:D(),firstNormalEpoch:l(),firstNormalSlot:l()}),Cn=ct(p(),k(l())),oe=b(F([h({}),p()])),Pn=h({err:oe}),Ln=C("receivedSignature"),Nn=h({"solana-core":p(),"feature-set":B(l())}),st=P(h({err:b(F([h({}),p()])),logs:b(k(p())),accounts:B(b(k(b(h({executable:D(),owner:p(),lamports:l(),data:k(p()),rentEpoch:B(l())}))))),unitsConsumed:B(l()),returnData:B(b(h({programId:p(),data:De([p(),C("base64")])})))})),Kn=P(h({byIdentity:ct(p(),k(l())),range:h({firstSlot:l(),lastSlot:l()})}));function qn(i,e,t,n,s,r){const o=t||mn;let c;r!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let u;return n&&(u=async(f,S)=>{const R=await new Promise((w,y)=>{try{n(f,S,(g,_)=>w([g,_]))}catch(g){y(g)}});return await o(...R)}),new a.RpcClient(async(f,S)=>{const R={method:"POST",body:f,agent:c,headers:Object.assign({"Content-Type":"application/json"},e||{},Fs)};try{let w=5,y,g=500;for(;u?y=await u(i,R):y=await o(i,R),!(y.status!==429||s===!0||(w-=1,w===0));)console.error(`Server responded with ${y.status} ${y.statusText}.  Retrying after ${g}ms delay...`),await ae(g),g*=2;const _=await y.text();y.ok?S(null,_):S(new Error(`${y.status} ${y.statusText}: ${_}`))}catch(w){w instanceof Error&&S(w)}},{})}function Fn(i){return(e,t)=>new Promise((n,s)=>{i.request(e,t,(r,o)=>{if(r){s(r);return}n(o)})})}function On(i){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(r=>i.request(r.methodName,r.args));i.request(s,(r,o)=>{if(r){n(r);return}t(o)})})}const Un=T(Rn),Mn=T(Tn),zn=T(En),Wn=T(xn),Dn=T(vn),Hn=T(Cn),Gn=T(l()),$n=P(h({total:l(),circulating:l(),nonCirculating:l(),nonCirculatingAccounts:k(N)})),Fe=h({amount:p(),uiAmount:b(l()),decimals:l(),uiAmountString:B(p())}),jn=P(k(h({address:N,amount:p(),uiAmount:b(l()),decimals:l(),uiAmountString:B(p())}))),Vn=P(k(h({pubkey:N,account:h({executable:D(),owner:N,lamports:l(),data:je,rentEpoch:l()})}))),Oe=h({program:p(),parsed:we(),space:l()}),Jn=P(k(h({pubkey:N,account:h({executable:D(),owner:N,lamports:l(),data:Oe,rentEpoch:l()})}))),Xn=P(k(h({lamports:l(),address:N}))),ye=h({executable:D(),owner:N,lamports:l(),data:je,rentEpoch:l()}),Yn=h({pubkey:N,account:ye}),Zn=ke(F([We(a.bufferPolyfill.Buffer),Oe]),F([yt,Oe]),i=>Array.isArray(i)?m(i,je):i),Ue=h({executable:D(),owner:N,lamports:l(),data:Zn,rentEpoch:l()}),Qn=h({pubkey:N,account:Ue}),es=h({state:F([C("active"),C("inactive"),C("activating"),C("deactivating")]),active:l(),inactive:l()}),ts=T(k(h({signature:p(),slot:l(),err:oe,memo:b(p()),blockTime:B(b(l()))}))),ns=T(k(h({signature:p(),slot:l(),err:oe,memo:b(p()),blockTime:B(b(l()))}))),ss=h({subscription:l(),result:xe(ye)}),rs=h({pubkey:N,account:ye}),os=h({subscription:l(),result:xe(rs)}),is=h({parent:l(),slot:l(),root:l()}),as=h({subscription:l(),result:is}),cs=F([h({type:F([C("firstShredReceived"),C("completed"),C("optimisticConfirmation"),C("root")]),slot:l(),timestamp:l()}),h({type:C("createdBank"),parent:l(),slot:l(),timestamp:l()}),h({type:C("frozen"),slot:l(),timestamp:l(),stats:h({numTransactionEntries:l(),numSuccessfulTransactions:l(),numFailedTransactions:l(),maxTransactionsPerEntry:l()})}),h({type:C("dead"),slot:l(),timestamp:l(),err:p()})]),us=h({subscription:l(),result:cs}),ls=h({subscription:l(),result:xe(F([Pn,Ln]))}),ds=h({subscription:l(),result:l()}),hs=h({pubkey:p(),gossip:b(p()),tpu:b(p()),rpc:b(p()),version:b(p())}),rt=h({votePubkey:p(),nodePubkey:p(),activatedStake:l(),epochVoteAccount:D(),epochCredits:k(De([l(),l(),l()])),commission:l(),lastVote:l(),rootSlot:b(l())}),fs=T(h({current:k(rt),delinquent:k(rt)})),gs=F([C("processed"),C("confirmed"),C("finalized")]),ps=h({slot:l(),confirmations:b(l()),err:oe,confirmationStatus:B(gs)}),ms=P(k(b(ps))),ys=T(l()),wt=h({accountKey:N,writableIndexes:k(l()),readonlyIndexes:k(l())}),Ve=h({signatures:k(p()),message:h({accountKeys:k(p()),header:h({numRequiredSignatures:l(),numReadonlySignedAccounts:l(),numReadonlyUnsignedAccounts:l()}),instructions:k(h({accounts:k(l()),data:p(),programIdIndex:l()})),recentBlockhash:p(),addressTableLookups:B(k(wt))})}),kt=h({pubkey:N,signer:D(),writable:D(),source:B(F([C("transaction"),C("lookupTable")]))}),St=h({accountKeys:k(kt),signatures:k(p())}),_t=h({parsed:we(),program:p(),programId:N}),At=h({accounts:k(N),data:p(),programId:N}),bs=F([At,_t]),ws=F([h({parsed:we(),program:p(),programId:p()}),h({accounts:k(p()),data:p(),programId:p()})]),It=ke(bs,ws,i=>"accounts"in i?m(i,At):m(i,_t)),Rt=h({signatures:k(p()),message:h({accountKeys:k(kt),instructions:k(It),recentBlockhash:p(),addressTableLookups:B(b(k(wt)))})}),Ee=h({accountIndex:l(),mint:p(),owner:B(p()),uiTokenAmount:Fe}),Bt=h({writable:k(N),readonly:k(N)}),ve=h({err:oe,fee:l(),innerInstructions:B(b(k(h({index:l(),instructions:k(h({accounts:k(l()),data:p(),programIdIndex:l()}))})))),preBalances:k(l()),postBalances:k(l()),logMessages:B(b(k(p()))),preTokenBalances:B(b(k(Ee))),postTokenBalances:B(b(k(Ee))),loadedAddresses:B(Bt),computeUnitsConsumed:B(l())}),Je=h({err:oe,fee:l(),innerInstructions:B(b(k(h({index:l(),instructions:k(It)})))),preBalances:k(l()),postBalances:k(l()),logMessages:B(b(k(p()))),preTokenBalances:B(b(k(Ee))),postTokenBalances:B(b(k(Ee))),loadedAddresses:B(Bt),computeUnitsConsumed:B(l())}),de=F([C(0),C("legacy")]),ie=h({pubkey:p(),lamports:l(),postBalance:b(l()),rewardType:b(p()),commission:B(b(l()))}),ks=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),transactions:k(h({transaction:Ve,meta:b(ve),version:B(de)})),rewards:B(k(ie)),blockTime:b(l()),blockHeight:b(l())}))),Ss=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),rewards:B(k(ie)),blockTime:b(l()),blockHeight:b(l())}))),_s=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),transactions:k(h({transaction:St,meta:b(ve),version:B(de)})),rewards:B(k(ie)),blockTime:b(l()),blockHeight:b(l())}))),As=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),transactions:k(h({transaction:Rt,meta:b(Je),version:B(de)})),rewards:B(k(ie)),blockTime:b(l()),blockHeight:b(l())}))),Is=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),transactions:k(h({transaction:St,meta:b(Je),version:B(de)})),rewards:B(k(ie)),blockTime:b(l()),blockHeight:b(l())}))),Rs=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),rewards:B(k(ie)),blockTime:b(l()),blockHeight:b(l())}))),Bs=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),transactions:k(h({transaction:Ve,meta:b(ve)})),rewards:B(k(ie)),blockTime:b(l())}))),ot=T(b(h({blockhash:p(),previousBlockhash:p(),parentSlot:l(),signatures:k(p()),blockTime:b(l())}))),Ne=T(b(h({slot:l(),meta:b(ve),blockTime:B(b(l())),transaction:Ve,version:B(de)}))),Ae=T(b(h({slot:l(),transaction:Rt,meta:b(Je),blockTime:B(b(l())),version:B(de)}))),Es=P(h({blockhash:p(),feeCalculator:h({lamportsPerSignature:l()})})),Ts=P(h({blockhash:p(),lastValidBlockHeight:l()})),xs=P(D()),vs=h({slot:l(),numTransactions:l(),numSlots:l(),samplePeriodSecs:l()}),Cs=T(k(vs)),Ps=P(b(h({feeCalculator:h({lamportsPerSignature:l()})}))),Ls=T(p()),Ns=T(p()),Ks=h({err:oe,logs:k(p()),signature:p()}),qs=h({result:xe(Ks),subscription:l()}),Fs={"solana-client":"js/0.0.0-development"};class Os{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const d={};return async f=>{const{commitment:S,config:R}=v(f),w=this._buildArgs([],S,void 0,R),y=et(w);return d[y]=d[y]??(async()=>{try{const g=await this._rpcRequest("getBlockHeight",w),_=m(g,T(l()));if("error"in _)throw new I(_.error,"failed to get block height information");return _.result}finally{delete d[y]}})(),await d[y]}})();let n,s,r,o,c,u;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,r=t.fetch,o=t.fetchMiddleware,c=t.disableRetryOnRateLimit,u=t.httpAgent),this._rpcEndpoint=An(e),this._rpcWsEndpoint=n||Sn(e),this._rpcClient=qn(e,s,r,o,c,u),this._rpcRequest=Fn(this._rpcClient),this._rpcBatchRequest=On(this._rpcClient),this._rpcWebSocket=new yn(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgs([e.toBase58()],n,void 0,s),o=await this._rpcRequest("getBalance",r),c=m(o,P(l()));if("error"in c)throw new I(c.error,`failed to get balance for ${e.toBase58()}`);return c.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=m(t,T(b(l())));if("error"in n)throw new I(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=m(e,T(l()));if("error"in t)throw new I(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=m(e,Gn);if("error"in t)throw new I(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=m(n,$n);if("error"in s)throw new I(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),r=m(s,P(Fe));if("error"in r)throw new I(r.error,"failed to get token supply");return r.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),r=m(s,P(Fe));if("error"in r)throw new I(r.error,"failed to get token account balance");return r.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:r}=v(n);let o=[e.toBase58()];"mint"in t?o.push({mint:t.mint.toBase58()}):o.push({programId:t.programId.toBase58()});const c=this._buildArgs(o,s,"base64",r),u=await this._rpcRequest("getTokenAccountsByOwner",c),d=m(u,Vn);if("error"in d)throw new I(d.error,`failed to get token accounts owned by account ${e.toBase58()}`);return d.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const r=this._buildArgs(s,n,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",r),c=m(o,Jn);if("error"in c)throw new I(c.error,`failed to get token accounts owned by account ${e.toBase58()}`);return c.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),r=m(s,Xn);if("error"in r)throw new I(r.error,"failed to get largest accounts");return r.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),r=m(s,jn);if("error"in r)throw new I(r.error,"failed to get token largest accounts");return r.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgs([e.toBase58()],n,"base64",s),o=await this._rpcRequest("getAccountInfo",r),c=m(o,P(b(ye)));if("error"in c)throw new I(c.error,`failed to get info about account ${e.toBase58()}`);return c.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getAccountInfo",r),c=m(o,P(b(Ue)));if("error"in c)throw new I(c.error,`failed to get info about account ${e.toBase58()}`);return c.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=v(t),r=e.map(d=>d.toBase58()),o=this._buildArgs([r],n,"jsonParsed",s),c=await this._rpcRequest("getMultipleAccounts",o),u=m(c,P(k(b(Ue))));if("error"in u)throw new I(u.error,`failed to get info for accounts ${r}`);return u.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=v(t),r=e.map(d=>d.toBase58()),o=this._buildArgs([r],n,"base64",s),c=await this._rpcRequest("getMultipleAccounts",o),u=m(c,P(k(b(ye))));if("error"in u)throw new I(u.error,`failed to get info for accounts ${r}`);return u.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:r}=v(t),o=this._buildArgs([e.toBase58()],s,void 0,{...r,epoch:n??(r==null?void 0:r.epoch)}),c=await this._rpcRequest("getStakeActivation",o),u=m(c,T(es));if("error"in u)throw new I(u.error,`failed to get Stake Activation ${e.toBase58()}`);return u.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=v(t),{encoding:r,...o}=s||{},c=this._buildArgs([e.toBase58()],n,r||"base64",o),u=await this._rpcRequest("getProgramAccounts",c),d=k(Yn),f=o.withContext===!0?m(u,P(d)):m(u,T(d));if("error"in f)throw new I(f.error,`failed to get accounts owned by program ${e.toBase58()}`);return f.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgs([e.toBase58()],n,"jsonParsed",s),o=await this._rpcRequest("getProgramAccounts",r),c=m(o,T(k(Qn)));if("error"in c)throw new I(c.error,`failed to get accounts owned by program ${e.toBase58()}`);return c.result}async confirmTransaction(e,t){var r;let n;if(typeof e=="string")n=e;else{const o=e;if((r=o.abortSignal)!=null&&r.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=a.bs58.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return L(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,r=!1;const o=new Promise((u,d)=>{try{n=this.onSignature(t,(S,R)=>{n=void 0;const w={context:R,value:S};u({__type:J.PROCESSED,response:w})},e);const f=new Promise(S=>{n==null?S():s=this._onSubscriptionStateChange(n,R=>{R==="subscribed"&&S()})});(async()=>{if(await f,r)return;const S=await this.getSignatureStatus(t);if(r||S==null)return;const{context:R,value:w}=S;if(w!=null)if(w!=null&&w.err)d(w.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(w.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(w.confirmationStatus==="processed"||w.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}r=!0,u({__type:J.PROCESSED,response:{context:R,value:w}})}})()}catch(f){d(f)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let r=!1;const o=new Promise(S=>{const R=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let w=await R();if(!r){for(;w<=n;)if(await ae(1e3),r||(w=await R(),r))return;S({__type:J.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),d=this.getCancellationPromise(t);let f;try{const S=await Promise.race([d,u,o]);if(S.__type===J.PROCESSED)f=S.response;else throw new He(s)}finally{r=!0,c()}return f}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:r,signature:o}}){let c=!1;const u=new Promise(w=>{let y=r,g=null;const _=async()=>{try{const{context:E,value:K}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return g=E.slot,K==null?void 0:K.nonce}catch{return y}};(async()=>{if(y=await _(),!c)for(;;){if(r!==y){w({__type:J.NONCE_INVALID,slotInWhichNonceDidAdvance:g});return}if(await ae(2e3),c||(y=await _(),c))return}})()}),{abortConfirmation:d,confirmationPromise:f}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),S=this.getCancellationPromise(t);let R;try{const w=await Promise.race([S,f,u]);if(w.__type===J.PROCESSED)R=w.response;else{let y;for(;;){const g=await this.getSignatureStatus(o);if(g==null)break;if(g.context.slot<(w.slotInWhichNonceDidAdvance??n)){await ae(400);continue}y=g;break}if(y!=null&&y.value){const g=e||"finalized",{confirmationStatus:_}=y.value;switch(g){case"processed":case"recent":if(_!=="processed"&&_!=="confirmed"&&_!=="finalized")throw new fe(o);break;case"confirmed":case"single":case"singleGossip":if(_!=="confirmed"&&_!=="finalized")throw new fe(o);break;case"finalized":case"max":case"root":if(_!=="finalized")throw new fe(o);break;default:}R={context:y.context,value:{err:y.value.err}}}else throw new fe(o)}}finally{c=!0,d()}return R}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(u=>{let d=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{d=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>u({__type:J.TIMED_OUT,timeoutMs:d}),d)}),{abortConfirmation:r,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let c;try{const u=await Promise.race([o,s]);if(u.__type===J.PROCESSED)c=u.response;else throw new ft(t,u.timeoutMs/1e3)}finally{clearTimeout(n),r()}return c}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=m(e,T(k(hs)));if("error"in t)throw new I(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=m(n,fs);if("error"in s)throw new I(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=v(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlot",s),o=m(r,T(l()));if("error"in o)throw new I(o.error,"failed to get slot");return o.result}async getSlotLeader(e){const{commitment:t,config:n}=v(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getSlotLeader",s),o=m(r,T(p()));if("error"in o)throw new I(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),r=m(s,T(k(N)));if("error"in r)throw new I(r.error,"failed to get slot leaders");return r.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);L(s.length===1);const r=s[0];return{context:n,value:r}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),r=m(s,ms);if("error"in r)throw new I(r.error,"failed to get signature status");return r.result}async getTransactionCount(e){const{commitment:t,config:n}=v(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getTransactionCount",s),o=m(r,T(l()));if("error"in o)throw new I(o.error,"failed to get transaction count");return o.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=m(n,Un);if("error"in s)throw new I(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:r}=v(n),o=this._buildArgs([e.map(d=>d.toBase58())],s,void 0,{...r,epoch:t??(r==null?void 0:r.epoch)}),c=await this._rpcRequest("getInflationReward",o),u=m(c,Bn);if("error"in u)throw new I(u.error,"failed to get inflation reward");return u.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=m(e,Mn);if("error"in t)throw new I(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=v(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getEpochInfo",s),o=m(r,Wn);if("error"in o)throw new I(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=m(e,Dn);if("error"in t)throw new I(t.error,"failed to get epoch schedule");const n=t.result;return new pn(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=m(e,Hn);if("error"in t)throw new I(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),r=m(s,ys);return"error"in r?(console.warn("Unable to fetch minimum balance for rent exemption"),0):r.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),s=m(n,Es);if("error"in s)throw new I(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=m(t,Cs);if("error"in n)throw new I(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),r=m(s,Ps);if("error"in r)throw new I(r.error,"failed to get fee calculator");const{context:o,value:c}=r.result;return{context:o,value:c!==null?c.feeCalculator:null}}async getFeeForMessage(e,t){const n=se(e.serialize()).toString("base64"),s=this._buildArgs([n],t),r=await this._rpcRequest("getFeeForMessage",s),o=m(r,P(b(l())));if("error"in o)throw new I(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(e){var o;const t=(o=e==null?void 0:e.lockedWritableAccounts)==null?void 0:o.map(c=>c.toBase58()),n=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),r=m(s,zn);if("error"in r)throw new I(r.error,"failed to get recent prioritization fees");return r.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=v(e),s=this._buildArgs([],t,void 0,n),r=await this._rpcRequest("getLatestBlockhash",s),o=m(r,Ts);if("error"in o)throw new I(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgs([e],n,void 0,s),o=await this._rpcRequest("isBlockhashValid",r),c=m(o,xs);if("error"in c)throw new I(c.error,"failed to determine if the blockhash `"+e+"`is valid");return c.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=m(e,T(Nn));if("error"in t)throw new I(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=m(e,T(p()));if("error"in t)throw new I(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const c=m(o,_s);if("error"in c)throw c.error;return c.result}case"none":{const c=m(o,Ss);if("error"in c)throw c.error;return c.result}default:{const c=m(o,ks);if("error"in c)throw c.error;const{result:u}=c;return u?{...u,transactions:u.transactions.map(({transaction:d,meta:f,version:S})=>({meta:f,transaction:{...d,message:Le(S,d.message)},version:S}))}:null}}}catch(c){throw new I(c,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getBlock",r);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const c=m(o,Is);if("error"in c)throw c.error;return c.result}case"none":{const c=m(o,Rs);if("error"in c)throw c.error;return c.result}default:{const c=m(o,As);if("error"in c)throw c.error;return c.result}}}catch(c){throw new I(c,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:c,...u}=e;n=c,t=u}const s=this._buildArgs([],n,"base64",t),r=await this._rpcRequest("getBlockProduction",s),o=m(r,Kn);if("error"in o)throw new I(o.error,"failed to get block production information");return o.result}async getTransaction(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgsAtLeastConfirmed([e],n,void 0,s),o=await this._rpcRequest("getTransaction",r),c=m(o,Ne);if("error"in c)throw new I(c.error,"failed to get transaction");const u=c.result;return u&&{...u,transaction:{...u.transaction,message:Le(u.version,u.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=v(t),r=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),o=await this._rpcRequest("getTransaction",r),c=m(o,Ae);if("error"in c)throw new I(c.error,"failed to get transaction");return c.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=v(t),r=e.map(u=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([u],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(r)).map(u=>{const d=m(u,Ae);if("error"in d)throw new I(d.error,"failed to get transactions");return d.result})}async getTransactions(e,t){const{commitment:n,config:s}=v(t),r=e.map(u=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([u],n,void 0,s)}));return(await this._rpcBatchRequest(r)).map(u=>{const d=m(u,Ne);if("error"in d)throw new I(d.error,"failed to get transactions");const f=d.result;return f&&{...f,transaction:{...f.transaction,message:Le(f.version,f.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",n),r=m(s,Bs);if("error"in r)throw new I(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");const c={...o,transactions:o.transactions.map(({transaction:u,meta:d})=>{const f=new j(u.message);return{meta:d,transaction:{...u,message:f}}})};return{...c,transactions:c.transactions.map(({transaction:u,meta:d})=>({meta:d,transaction:X.populate(u.message,u.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),r=await this._rpcRequest("getBlocks",s),o=m(r,T(k(l())));if("error"in o)throw new I(o.error,"failed to get blocks");return o.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),r=m(s,ot);if("error"in r)throw new I(r.error,"failed to get block");const o=r.result;if(!o)throw new Error("Block "+e+" not found");return o}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",n),r=m(s,ot);if("error"in r)throw new I(r.error,"failed to get confirmed block");const o=r.result;if(!o)throw new Error("Confirmed block "+e+" not found");return o}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",n),r=m(s,Ne);if("error"in r)throw new I(r.error,"failed to get transaction");const o=r.result;if(!o)return o;const c=new j(o.transaction.message),u=o.transaction.signatures;return{...o,transaction:X.populate(c,u)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",n),r=m(s,Ae);if("error"in r)throw new I(r.error,"failed to get confirmed transaction");return r.result}async getParsedConfirmedTransactions(e,t){const n=e.map(o=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([o],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(o=>{const c=m(o,Ae);if("error"in c)throw new I(c.error,"failed to get confirmed transactions");return c.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},r=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<r));)try{const u=await this.getConfirmedBlockSignatures(t,"finalized");u.signatures.length>0&&(s.until=u.signatures[u.signatures.length-1].toString())}catch(u){if(u instanceof Error&&u.message.includes("skipped"))continue;throw u}let o=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>o));)try{const u=await this.getConfirmedBlockSignatures(n);u.signatures.length>0&&(s.before=u.signatures[u.signatures.length-1].toString())}catch(u){if(u instanceof Error&&u.message.includes("skipped"))continue;throw u}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(u=>u.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),o=m(r,ts);if("error"in o)throw new I(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),r=await this._rpcRequest("getSignaturesForAddress",s),o=m(r,ns);if("error"in o)throw new I(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=new nt({key:e,state:nt.deserialize(s.data)})),{context:n,value:r}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let r=null;return s!==null&&(r=$e.fromAccountData(s.data)),{context:n,value:r}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=m(n,Ls);if("error"in s)throw new I(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await ae(100);const n=Date.now()-this._blockhashInfo.lastFetch>=_n;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const r=await this.getLatestBlockhash("finalized");if(n!==r.blockhash)return this._blockhashInfo={latestBlockhash:r,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},r;await ae(on/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=v(e),s=this._buildArgs([],t,"base64",n),r=await this._rpcRequest("getStakeMinimumDelegation",s),o=m(r,P(l()));if("error"in o)throw new I(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(e,t,n){if("message"in e){const g=e.serialize(),_=a.bufferPolyfill.Buffer.from(g).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const E=t||{};E.encoding="base64","commitment"in E||(E.commitment=this.commitment);const K=[_,E],ee=await this._rpcRequest("simulateTransaction",K),V=m(ee,st);if("error"in V)throw new Error("failed to simulate transaction: "+V.error.message);return V.result}let s;if(e instanceof X){let y=e;s=new X,s.feePayer=y.feePayer,s.instructions=e.instructions,s.nonceInfo=y.nonceInfo,s.signatures=y.signatures}else s=X.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(s.nonceInfo&&r)s.sign(...r);else{let y=this._disableBlockhashCaching;for(;;){const g=await this._blockhashWithExpiryBlockHeight(y);if(s.lastValidBlockHeight=g.lastValidBlockHeight,s.recentBlockhash=g.blockhash,!r)break;if(s.sign(...r),!s.signature)throw new Error("!signature");const _=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(_)&&!this._blockhashInfo.transactionSignatures.includes(_)){this._blockhashInfo.simulatedSignatures.push(_);break}else y=!0}}const o=s._compile(),c=o.serialize(),d=s._serialize(c).toString("base64"),f={encoding:"base64",commitment:this.commitment};if(n){const y=(Array.isArray(n)?n:o.nonProgramIds()).map(g=>g.toBase58());f.accounts={encoding:"base64",addresses:y}}r&&(f.sigVerify=!0);const S=[d,f],R=await this._rpcRequest("simulateTransaction",S),w=m(R,st);if("error"in w){let y;if("data"in w.error&&(y=w.error.data.logs,y&&Array.isArray(y))){const g=`
    `,_=g+y.join(g);console.error(w.error.message,_)}throw new qe("failed to simulate transaction: "+w.error.message,y)}return w.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const o=e.serialize();return await this.sendRawTransaction(o,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let o=this._disableBlockhashCaching;for(;;){const c=await this._blockhashWithExpiryBlockHeight(o);if(e.lastValidBlockHeight=c.lastValidBlockHeight,e.recentBlockhash=c.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const u=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(u))o=!0;else{this._blockhashInfo.transactionSignatures.push(u);break}}}const r=e.serialize();return await this.sendRawTransaction(r,n)}async sendRawTransaction(e,t){const n=se(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,r=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),r&&(n.preflightCommitment=r);const o=[e,n],c=await this._rpcRequest("sendTransaction",o),u=m(c,Ns);if("error"in u){let d;throw"data"in u.error&&(d=u.error.data.logs),new qe("failed to send transaction: "+u.error.message,d)}return u.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var s;const n=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var r;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=(r=this._subscriptionStateChangeCallbacksByHash)[n]||(r[n]=new Set);return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:r,method:o}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const c=await this._rpcWebSocket.call(o,r);this._setSubscription(n,{...s,serverSubscriptionId:c,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[c]=s.callbacks,await this._updateSubscriptions()}catch(c){if(c instanceof Error&&console.error(`${o} error for argument`,r,c.message),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:r,unsubscribeMethod:o}=s;if(this._subscriptionsAutoDisposedByRpc.has(r))this._subscriptionsAutoDisposedByRpc.delete(r);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[r])}catch(c){if(c instanceof Error&&console.error(`${o} error:`,c.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(r){console.error(r)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=m(e,ss);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=et([e.method,t]),r=this._subscriptionsByHash[s];return r===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:r.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const o=this._subscriptionsByHash[s];L(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),o.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=m(e,os);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const r=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},r)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=m(e,qs);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=m(e,as);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=m(e,us);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const r=t||this._commitment;if(r||n||s){let o={};n&&(o.encoding=n),r&&(o.commitment=r),s&&(o=Object.assign(o,s)),e.push(o)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const r=t||this._commitment;if(r&&!["confirmed","finalized"].includes(r))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=m(e,ls);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),r=this._makeSubscription({callback:(o,c)=>{if(o.type==="status"){t(o.result,c);try{this.removeSignatureListener(r)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return r}onSignatureWithOptions(e,t,n){const{commitment:s,...r}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},o=this._buildArgs([e],s,void 0,r),c=this._makeSubscription({callback:(u,d)=>{t(u,d);try{this.removeSignatureListener(c)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return c}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=m(e,ds);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class pe{constructor(e){this._keypair=void 0,this._keypair=e??Ye()}static generate(){return new pe(Ye())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),r=Ke(s);for(let o=0;o<32;o++)if(n[o]!==r[o])throw new Error("provided secretKey is invalid")}return new pe({publicKey:n,secretKey:e})}static fromSeed(e){const t=Ke(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new pe({publicKey:t,secretKey:n})}get publicKey(){return new A(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:a.struct([a.u32("instruction"),le("recentSlot"),a.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:a.struct([a.u32("instruction")])},ExtendLookupTable:{index:2,layout:a.struct([a.u32("instruction"),le(),a.seq(x(),a.offset(a.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:a.struct([a.u32("instruction")])},CloseLookupTable:{index:4,layout:a.struct([a.u32("instruction")])}});new A("AddressLookupTab1e1111111111111111111111111");const Ie=Object.freeze({RequestUnits:{index:0,layout:a.struct([a.u8("instruction"),a.u32("units"),a.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:a.struct([a.u8("instruction"),a.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:a.struct([a.u8("instruction"),a.u32("units")])},SetComputeUnitPrice:{index:3,layout:a.struct([a.u8("instruction"),le("microLamports")])}});class Me{constructor(){}static requestUnits(e){const t=Ie.RequestUnits,n=_e(t,e);return new ne({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=Ie.RequestHeapFrame,n=_e(t,e);return new ne({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=Ie.SetComputeUnitLimit,n=_e(t,e);return new ne({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=Ie.SetComputeUnitPrice,n=_e(t,{microLamports:BigInt(e.microLamports)});return new ne({keys:[],programId:this.programId,data:n})}}Me.programId=new A("ComputeBudget111111111111111111111111111111");a.struct([a.u8("numSignatures"),a.u8("padding"),a.u16("signatureOffset"),a.u16("signatureInstructionIndex"),a.u16("publicKeyOffset"),a.u16("publicKeyInstructionIndex"),a.u16("messageDataOffset"),a.u16("messageDataSize"),a.u16("messageInstructionIndex")]);new A("Ed25519SigVerify111111111111111111111111111");a.secp256k1.utils.isValidPrivateKey;a.secp256k1.getPublicKey;a.struct([a.u8("numSignatures"),a.u16("signatureOffset"),a.u8("signatureInstructionIndex"),a.u16("ethAddressOffset"),a.u8("ethAddressInstructionIndex"),a.u16("messageDataOffset"),a.u16("messageDataSize"),a.u8("messageInstructionIndex"),a.blob(20,"ethAddress"),a.blob(64,"signature"),a.u8("recoveryId")]);new A("KeccakSecp256k11111111111111111111111111111");var Et;new A("StakeConfig11111111111111111111111111111111");class Tt{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Et=Tt;Tt.default=new Et(0,0,A.default);Object.freeze({Initialize:{index:0,layout:a.struct([a.u32("instruction"),Yt(),Zt()])},Authorize:{index:1,layout:a.struct([a.u32("instruction"),x("newAuthorized"),a.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:a.struct([a.u32("instruction")])},Split:{index:3,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},Withdraw:{index:4,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},Deactivate:{index:5,layout:a.struct([a.u32("instruction")])},Merge:{index:7,layout:a.struct([a.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:a.struct([a.u32("instruction"),x("newAuthorized"),a.u32("stakeAuthorizationType"),ce("authoritySeed"),x("authorityOwner")])}});new A("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:a.struct([a.u32("instruction"),Qt()])},Authorize:{index:1,layout:a.struct([a.u32("instruction"),x("newAuthorized"),a.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:a.struct([a.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:a.struct([a.u32("instruction"),en()])}});new A("Vote111111111111111111111111111111111111111");new A("Va1idator1nfo111111111111111111111111111111");h({name:p(),website:B(p()),details:B(p()),keybaseUsername:B(p())});new A("Vote111111111111111111111111111111111111111");a.struct([x("nodePubkey"),x("authorizedWithdrawer"),a.u8("commission"),a.nu64(),a.seq(a.struct([a.nu64("slot"),a.u32("confirmationCount")]),a.offset(a.u32(),-8),"votes"),a.u8("rootSlotValid"),a.nu64("rootSlot"),a.nu64(),a.seq(a.struct([a.nu64("epoch"),x("authorizedVoter")]),a.offset(a.u32(),-8),"authorizedVoters"),a.struct([a.seq(a.struct([x("authorizedPubkey"),a.nu64("epochOfLastAuthorizedSwitch"),a.nu64("targetEpoch")]),32,"buf"),a.nu64("idx"),a.u8("isEmpty")],"priorVoters"),a.nu64(),a.seq(a.struct([a.nu64("epoch"),a.nu64("credits"),a.nu64("prevCredits")]),a.offset(a.u32(),-8),"epochCredits"),a.struct([a.nu64("slot"),a.nu64("timestamp")],"lastTimestamp")]);const Se="Solana",Us="11111111111111111111111111111111",te=class te{constructor(e){q(this,"type","Native");q(this,"address");te.instanceof(e)?this.address=e.address:a.UniversalAddress.instanceof(e)?this.address=new A(e.toUint8Array()):typeof e=="string"&&a.hex.valid(e)?this.address=new A(a.hex.decode(e)):this.address=new A(e)}unwrap(){return this.address}toString(){return this.address.toBase58()}toUint8Array(){return new Uint8Array(this.address.toBytes())}toNative(){return this}toUniversalAddress(){return new a.UniversalAddress(this.toUint8Array())}static instanceof(e){return e.constructor.platform===te.platform}equals(e){return te.instanceof(e)?e.unwrap().equals(this.unwrap()):this.toUniversalAddress().equals(e)}};q(te,"byteSize",32),q(te,"platform",Se);let z=te;a.registerNative(Se,z);class xt extends it.ChainContext{async getTokenAccount(e,t){const{getAssociatedTokenAddress:n}=await Promise.resolve().then(()=>require("./index-CbUGjmwc.js")),s=new z(t).unwrap(),r=new z(e).unwrap(),o=await n(s,r);return{chain:this.chain,address:new z(o.toString())}}}const vt=new A("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new A("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const Ms=new A("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new A("So11111111111111111111111111111111111111112");new A("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const G=class G extends it.PlatformContext{constructor(e,t){super(e,t??a.networkPlatformConfigs(e,G._platform))}getRpc(e,t={commitment:"confirmed",disableRetryOnRateLimit:!0}){if(e in this.config)return new Os(this.config[e].rpc,t);throw new Error("No configuration available for chain: "+e)}getChain(e,t){if(e in this.config)return new xt(e,this,t);throw new Error("No configuration available for chain: "+e)}static nativeTokenId(e,t){if(!G.isSupportedChain(t))throw new Error(`invalid chain: ${t}`);return a.Wormhole.chainAddress(t,Us)}static isNativeTokenId(e,t,n){return!this.isSupportedChain(t)||n.chain!==t?!1:this.nativeTokenId(e,t)==n}static isSupportedChain(e){return a.chainToPlatform(e)===G._platform}static async getDecimals(e,t,n){if(a.isNative(n))return a.nativeDecimals(G._platform);let s=await t.getParsedAccountInfo(new z(n).unwrap());if(!s||!s.value)throw new Error("could not fetch token details");const{decimals:r}=s.value.data.parsed.info;return r}static async getBalance(e,t,n,s){const r=new A(n);if(a.isNative(s))return BigInt(await t.getBalance(r));const o=await t.getTokenAccountsByOwner(r,{mint:new z(s).unwrap()}),c=o.value.length>0?o.value[0].pubkey:r,u=await t.getTokenAccountBalance(c);return BigInt(u.value.amount)}static async getBalances(e,t,n,s){let r;s.includes("native")&&(r=BigInt(await t.getBalance(new A(n))));const o=await t.getParsedTokenAccountsByOwner(new A(n),{programId:new A(vt)});return s.map(u=>{var S,R,w,y;if(a.isNative(u))return{native:r};const d=new z(u).toString(),f=(y=(w=(R=(S=o.value.find(g=>{var _,E;return((E=(_=g==null?void 0:g.account.data.parsed)==null?void 0:_.info)==null?void 0:E.mint)===u}))==null?void 0:S.account.data.parsed)==null?void 0:R.info)==null?void 0:w.tokenAmount)==null?void 0:y.amount;return f?{[d]:BigInt(f)}:{[d]:null}}).reduce((u,d)=>Object.assign(u,d),{})}static async sendWait(e,t,n,s){const{blockhash:r,lastValidBlockHeight:o}=await this.latestBlock(t),c=await Promise.all(n.map(f=>t.sendRawTransaction(f,s??{preflightCommitment:t.commitment}))),d=(await Promise.all(c.map(f=>t.confirmTransaction({signature:f,blockhash:r,lastValidBlockHeight:o},t.commitment)))).filter(f=>f.value.err).map(f=>f.value.err);if(d.length>0)throw new Error(`Failed to confirm transaction: ${d}`);return c}static async latestBlock(e,t){return e.getLatestBlockhash(t??e.commitment)}static async getLatestBlock(e){return await e.getSlot()}static async getLatestFinalizedBlock(e){const{lastValidBlockHeight:t}=await this.latestBlock(e,"finalized");return t}static chainFromChainId(e){const t=a.platformNativeChainIdToNetworkChain(G._platform,e);if(!t)throw new Error(`No matching genesis hash to determine network and chain: ${e}`);const[n,s]=t;return[n,s]}static async chainFromRpc(e){try{const t=await e.getGenesisHash();return G.chainFromChainId(t)}catch(t){if(e.rpcEndpoint.includes("http://127")||e.rpcEndpoint.includes("http://localhost")||e.rpcEndpoint==="http://solana-devnet:8899")return["Devnet","Solana"];throw t}}};q(G,"_platform",Se);let Q=G;class zs{constructor(e,t,n,s,r=!1){q(this,"transaction");q(this,"network");q(this,"chain");q(this,"description");q(this,"parallelizable");this.transaction=e,this.network=t,this.chain=n,this.description=s,this.parallelizable=r}}function Ce(i){return i.signatures!==void 0&&i.message!==void 0}const Ct=.5,Pt=1,Lt=1,Nt=1e9,Kt=5,Ws=25e4;async function Ds(i,e,t){const[n,s]=await Q.chainFromRpc(i),r=typeof e=="string"?pe.fromSecretKey(a.b58.decode(e)):e;if(t!=null&&t.priorityFee&&t.priorityFee.percentile&&t.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new Hs(i,s,r,(t==null?void 0:t.debug)??!1,(t==null?void 0:t.priorityFee)??{},(t==null?void 0:t.retries)??Kt,t==null?void 0:t.sendOpts)}class Hs{constructor(e,t,n,s=!1,r,o=Kt,c){q(this,"_rpc");q(this,"_chain");q(this,"_keypair");q(this,"_debug");q(this,"_priorityFee");q(this,"_maxResubmits");q(this,"_sendOpts");this._rpc=e,this._chain=t,this._keypair=n,this._debug=s,this._priorityFee=r,this._maxResubmits=o,this._sendOpts=c,this._sendOpts=this._sendOpts??{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(e){var n;if(e instanceof He)return!0;if(!(e instanceof qe)||!e.message.includes("Transaction simulation failed"))return!1;if(e.message.includes("Blockhash not found"))return!0;const t=(n=e.logs)==null?void 0:n.find(s=>s.startsWith("Program log: Error: "));return t?!!(t.includes("Not enough bytes")||t.includes("Unexpected length of input")):!1}async signAndSend(e){var c;let{blockhash:t,lastValidBlockHeight:n}=await Q.latestBlock(this._rpc);const s=[];for(const u of e){const{description:d,transaction:{transaction:f,signers:S}}=u;this._debug&&console.log(`Signing: ${d} for ${this.address()}`);let R;(c=this._priorityFee)!=null&&c.percentile&&this._priorityFee.percentile>0&&(R=await $s(this._rpc,f,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&Gs(f);for(let w=0;w<this._maxResubmits;w++)try{if(Ce(f)){if(R){const g=Ge.decompile(f.message);g.instructions.push(...R),f.message=g.compileToV0Message()}f.message.recentBlockhash=t,f.sign([this._keypair,...S??[]])}else R&&f.add(...R),f.recentBlockhash=t,f.partialSign(this._keypair,...S??[]);this._debug&&console.log("Submitting transactions ");const y=await this._rpc.sendRawTransaction(f.serialize(),this._sendOpts);s.push(y);break}catch(y){if(w===this._maxResubmits-1||!this.retryable(y))throw y;this._debug&&console.log(`Failed to send transaction on attempt ${w}, retrying: `,y);const{blockhash:g,lastValidBlockHeight:_}=await Q.latestBlock(this._rpc);n=_,t=g}}this._debug&&console.log("Waiting for confirmation for: ",s);const o=(await Promise.all(s.map(async u=>{try{return await this._rpc.confirmTransaction({signature:u,blockhash:t,lastValidBlockHeight:n},this._rpc.commitment)}catch(d){throw console.error("Failed to confirm transaction: ",d),d}}))).filter(u=>u.value.err).map(u=>u.value.err);if(o.length>0)throw new Error(`Failed to confirm transaction: ${o}`);return s}}function Gs(i){if(Ce(i)){console.log(i.signatures);const e=i.message,t=e.getAccountKeys();e.compiledInstructions.forEach(n=>{console.log("Program",t.get(n.programIdIndex).toBase58()),console.log("Data: ",a.hex.encode(n.data)),console.log("Keys: ",n.accountKeyIndexes.map(s=>[s,t.get(s).toBase58()]))})}else console.log(i.signatures),console.log(i.feePayer),i.instructions.forEach(e=>{console.log("Program",e.programId.toBase58()),console.log("Data: ",e.data.toString("hex")),console.log("Keys: ",e.keys.map(t=>[t,t.pubkey.toBase58()]))})}async function $s(i,e,t=Ct,n=Pt,s=Lt,r=Nt){const[o,c]=await Promise.all([js(i,e),Vs(i,e,t,n,s,r)]);return[Me.setComputeUnitLimit({units:o}),Me.setComputeUnitPrice({microLamports:c})]}async function js(i,e){var n;let t=Ws;try{const s=await(Ce(e),i.simulateTransaction(e));s.value.err&&console.error(`Error simulating Solana transaction: ${s.value.err}`),(n=s==null?void 0:s.value)!=null&&n.unitsConsumed&&(t=Math.round(s.value.unitsConsumed*1.2))}catch(s){console.error(`Failed to calculate compute unit limit for Solana transaction: ${s}`)}return t}async function Vs(i,e,t=Ct,n=Pt,s=Lt,r=Nt){let o=s,c=[];if(Ce(e)){const u=e.message,d=u.getAccountKeys();c=u.compiledInstructions.flatMap(f=>f.accountKeyIndexes).map(f=>u.isAccountWritable(f)?d.get(f):null).filter(f=>f!==null)}else c=e.instructions.flatMap(u=>u.keys).map(u=>u.isWritable?u.pubkey:null).filter(u=>u!==null);try{const u=await i.getRecentPrioritizationFees({lockedWritableAccounts:c});if(u){const d=u.map(S=>S.prioritizationFee).sort((S,R)=>S-R),f=Math.ceil(d.length*t);if(d.length>f){let S=d[f];n>0&&(S*=n),o=Math.max(o,S)}}}catch(u){console.error("Error fetching Solana recent fees",u)}return Math.min(Math.max(o,s),r)}const Js={Address:z,Platform:Q,getSigner:Ds,protocols:{WormholeCore:()=>Promise.resolve().then(()=>require("./index-4YwoNoJ9.js")).then(i=>i.index),TokenBridge:()=>Promise.resolve().then(()=>require("./index-2Tp1cDwc.js")),CircleBridge:()=>Promise.resolve().then(()=>require("./index-Bw2jWOFY.js"))},getChain:(i,e,t)=>new xt(e,new Q(i,a.applyChainsConfigConfigOverrides(i,Se,{[e]:t})))},Xs=Object.freeze(Object.defineProperty({__proto__:null,default:Js},Symbol.toStringTag,{value:"Module"}));exports.ASSOCIATED_TOKEN_PROGRAM_ID=Ms;exports.PublicKey=A;exports.SolanaAddress=z;exports.SolanaPlatform=Q;exports.SolanaUnsignedTransaction=zs;exports.TOKEN_PROGRAM_ID=vt;exports._platform=Se;exports.solana=Xs;

"use strict";var u=Object.defineProperty;var w=(i,e,r)=>e in i?u(i,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):i[e]=r;var c=(i,e,r)=>(w(i,typeof e!="symbol"?e+"":e,r),r);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("./cosmwasm-Cs-vbaNE.js"),l=require("./create-C7G6iKS_.js"),h=require("./index-BMvV5qga.js"),g=require("./chain-DBb0uF1j.js");class o{constructor(e,r,s,t){c(this,"network");c(this,"chain");c(this,"rpc");c(this,"contracts");c(this,"coreAddress");this.network=e,this.chain=r,this.rpc=s,this.contracts=t;const n=this.contracts.coreBridge;if(!n)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);this.coreAddress=n}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,r){const[s,t]=await m.CosmwasmPlatform.chainFromRpc(e),n=r[t];if(n.network!==s)throw new Error(`Network mismatch: ${n.network} != ${s}`);return new o(s,t,e,n.contracts)}async*publishMessage(e,r,s,t){throw new Error("Method not implemented.")}async*verifyMessage(e,r){throw new Error("Not implemented.")}async parseTransaction(e){const r=await this.rpc.getTx(e);if(!r)throw new Error("No transaction found for txid: "+e);return[o.parseWormholeMessageId(this.chain,this.coreAddress,r)]}async parseMessages(e){const r=await this.rpc.getTx(e);if(!r)throw new Error("No transaction found for txid: "+e);return[o.parseWormholeMessage(this.chain,this.coreAddress,r)]}static parseWormholeMessage(e,r,s){const t=s.events.filter(a=>a.type==="wasm"&&a.attributes[0].key==="_contract_address"&&a.attributes[0].value===r);if(t.length===0)throw new Error("No wormhole message found in tx");t.length>1&&console.error(`Expected single message, found ${t.length}`);const[n]=t,d=Object.fromEntries(n.attributes.map(a=>[a.key.split(".")[1],a.value]));return l.createVAA("Uint8Array",{emitterChain:e,emitterAddress:new h.UniversalAddress(h.hex.decode(d.sender)),sequence:BigInt(d.sequence),guardianSet:0,timestamp:Number(d.block_time),consistencyLevel:0,nonce:Number(d.nonce),signatures:[],payload:h.hex.decode(d.message)})}static parseWormholeMessageId(e,r,s){const t=o.parseWormholeMessage(e,r,s);return{chain:t.emitterChain,emitter:t.emitterAddress,sequence:t.sequence}}}g.registerProtocol(m._platform,"WormholeCore",o);exports.CosmwasmWormholeCore=o;

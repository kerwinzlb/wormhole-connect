"use strict";var u=Object.defineProperty;var d=(o,t,i)=>t in o?u(o,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[t]=i;var e=(o,t,i)=>(d(o,typeof t!="symbol"?t+"":t,i),i);const n=require("./index-BMvV5qga.js");function f(o){return"getVersion"in o}const s={};function m(o,t,i){t in s||(s[t]={});const r=s[t];if(o in r)throw new Error(`Protocol ${o} for protocol ${t} has already registered`);s[t][o]=i}function w(o,t){const i=n.isChain(o)?n.chainToPlatform.get(o):o;return t in s?i in s[t]:!1}function l(o,t){if(t in s){const i=s[t];if(i&&o in i){const r=i[o];if(r)return r}}throw new Error(`No protocols registered for ${o}:${t}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`)}const B=(o,t,i,r)=>l(o,t).fromRpc(i,r);class k{constructor(t,i){e(this,"network");e(this,"config");this.network=t,this.config=i}utils(){return this.constructor}getProtocol(t,i){return B(this.utils()._platform,t,i,this.config)}getProtocolInitializer(t){return l(this.utils()._platform,t)}async parseWormholeMessages(t,i,r){return(await this.getProtocol("WormholeCore",i)).parseTransaction(r)}}class P{constructor(t,i,r){e(this,"network");e(this,"chain");e(this,"config");e(this,"platform");e(this,"rpc");e(this,"protocols",new Map);e(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore"));e(this,"getWormholeCore",()=>this.getProtocol("WormholeCore"));e(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge"));e(this,"getTokenBridge",()=>this.getProtocol("TokenBridge"));e(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge"));e(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge"));e(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge"));e(this,"getCircleBridge",()=>this.getProtocol("CircleBridge"));e(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge"));e(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge"));e(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge"));e(this,"getIbcBridge",()=>this.getProtocol("IbcBridge"));e(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge"));e(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge"));this.config=i.config[t],this.platform=i,this.chain=this.config.key,this.network=this.config.network,this.rpc=r}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if(n.isNative(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const i=n.canonicalAddress({chain:this.chain,address:t}),r=n.getTokenByAddress(this.network,this.chain,i);if(r)return r.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,i){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,i)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:i}=this.config.wrappedNative;return{chain:this.chain,address:n.toNative(this.chain,i)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,i){return{chain:this.chain,address:t}}supportsProtocol(t){return w(this.chain,t)}async getProtocol(t,i,r){if(!i&&this.protocols.has(t))return this.protocols.get(t);const c=i?{...this.config.contracts,...i}:this.config.contracts,h=r??await this.getRpc(),g=this.platform.getProtocolInitializer(t);let a;if(r){if(i)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");a=await this.platform.getProtocol(t,h)}else if(f(g)){const p=await g.getVersion(h,c);a=new g(this.network,this.chain,h,c,p)}else a=new g(this.network,this.chain,h,c);return i||this.protocols.set(t,a),a}}exports.ChainContext=P;exports.PlatformContext=k;exports.registerProtocol=m;

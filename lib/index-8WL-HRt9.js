"use strict";var U=Object.defineProperty;var R=(T,n,e)=>n in T?U(T,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):T[n]=e;var A=(T,n,e)=>(R(T,typeof n!="symbol"?n+"":n,e),e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const p=require("./index-DyKKa0fa.js"),t=require("./index-BMvV5qga.js"),c=require("./algorand-B47Qnita.js"),q=require("./chain-DBb0uF1j.js"),W=t.ABIMethod.fromSignature("portal_transfer(byte[])byte[]"),g=class g{constructor(n,e,r,s){A(this,"network");A(this,"chain");A(this,"connection");A(this,"contracts");A(this,"chainId");A(this,"coreBridge");A(this,"coreAppId");A(this,"coreAppAddress");A(this,"tokenBridgeAppId");A(this,"tokenBridgeAddress");if(this.network=n,this.chain=e,this.connection=r,this.contracts=s,this.chainId=t.toChainId(e),!s.coreBridge)throw new Error(`Core contract address for chain ${e} not found`);const i=BigInt(s.coreBridge);if(this.coreAppId=i,this.coreAppAddress=t.getApplicationAddress(i),this.coreBridge=new p.AlgorandWormholeCore(n,e,r,s),!s.tokenBridge)throw new Error(`TokenBridge contract address for chain ${e} not found`);const a=BigInt(s.tokenBridge);this.tokenBridgeAppId=a,this.tokenBridgeAddress=t.getApplicationAddress(a)}static async fromRpc(n,e){const[r,s]=await c.AlgorandPlatform.chainFromRpc(n),i=e[s];if(i.network!==r)throw new Error(`Network mismatch: ${i.network} != ${r}`);return new g(r,s,n,i.contracts)}async isWrappedAsset(n){const e=new c.AlgorandAddress(n).toInt();if(e===0)return!1;const r=await this.connection.getAssetByID(e).do(),i=t.Asset.from_obj_for_encoding(r).params.creator,a=await this.connection.accountInformation(i).exclude("all").do(),o=t.Account.from_obj_for_encoding(a);return(o==null?void 0:o.authAddr)===this.tokenBridgeAddress}async getOriginalAsset(n){const e=new c.AlgorandAddress(n).toInt(),r=await this.connection.getAssetByID(e).do(),s=t.Asset.from_obj_for_encoding(r),i=await p.StorageLogicSig.decodeLocalState(this.connection,this.tokenBridgeAppId,s.params.creator);if(i.length<94)throw new Error("Invalid local state data");const a=i.slice(92,94),o=t.toChain(t.bignum.decode(a)),l=new t.UniversalAddress(i.slice(60,92));return{chain:o,address:l}}async getWrappedAsset(n){const e=p.StorageLogicSig.forWrappedAsset(this.tokenBridgeAppId,n),r=await p.StorageLogicSig.decodeLocalState(this.connection,this.tokenBridgeAppId,e.address());if(r.length<8)throw new Error("Invalid wrapped asset data");return t.toNative(this.chain,t.bignum.decode(r.slice(0,8)).toString())}async hasWrappedAsset(n){try{return await this.getWrappedAsset(n),!0}catch{}return!1}async getWrappedNative(){return t.toNative(this.chain,"0")}async isTransferCompleted(n){const e=p.StorageLogicSig.forMessageId(this.tokenBridgeAppId,{sequence:n.sequence,chain:n.emitterChain,emitter:n.emitterAddress});try{return await p.StorageLogicSig.checkBitsSet(this.connection,this.tokenBridgeAppId,e.address(),n.sequence)}catch{}return!1}async*createAttestation(n,e){if(!e)throw new Error("Payer required to create attestation");const r=new c.AlgorandAddress(e).toString(),s=new c.AlgorandAddress(n).toInt(),i=[],a=await this.connection.getTransactionParams().do(),o=p.StorageLogicSig.forEmitter(this.coreAppId,new c.AlgorandAddress(this.tokenBridgeAddress).toUint8Array()),{accounts:[l],txs:x}=await p.AlgorandWormholeCore.maybeCreateStorageTx(this.connection,r,this.coreAppId,o,a);i.push(...x);let f="",d;if(s!==0){const I=await this.connection.getAssetByID(s).do(),S=t.Asset.from_obj_for_encoding(I),C=await this.connection.accountInformation(S.params.creator).do();if(d=t.Account.from_obj_for_encoding(C),d.authAddr===this.tokenBridgeAddress.toString())throw new Error("Cannot re-attest wormhole assets")}const w=p.StorageLogicSig.forNativeAsset(this.tokenBridgeAppId,BigInt(s)),k=await p.AlgorandWormholeCore.maybeCreateStorageTx(this.connection,r,this.tokenBridgeAppId,w);f=k.accounts[0],i.push(...k.txs);const u=t.makeApplicationCallTxnFromObject({from:r,appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),onComplete:t.OnApplicationComplete.NoOpOC,appArgs:[g.noop],suggestedParams:a});i.push({tx:u});const m=await this.coreBridge.getMessageFee();if(m>BigInt(0)){const I=t.makePaymentTxnWithSuggestedParamsFromObject({from:r,suggestedParams:a,to:this.tokenBridgeAddress,amount:m});i.push({tx:I})}let b=[l,f,this.coreAppAddress];d&&b.push(d.address);let h=t.makeApplicationCallTxnFromObject({appArgs:[g.attestToken,t.bignum.toBytes(s,8)],accounts:b,appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),foreignApps:[c.safeBigIntToNumber(this.coreAppId)],foreignAssets:[s],from:r,onComplete:t.OnApplicationComplete.NoOpOC,suggestedParams:a});m>BigInt(0)?h.fee*=3:h.fee*=2,i.push({tx:h});for(const I of i)yield this.createUnsignedTx(I,"TokenBridge.createAttestation",!0)}async*submitAttestation(n,e,r){if(!e)throw new Error("Sender required to submit attestation");r||(r=await this.connection.getTransactionParams().do());const s=e.toString(),a=p.StorageLogicSig.forWrappedAsset(this.tokenBridgeAppId,n.payload.token).address(),o=[],l=[],x=await p.StorageLogicSig.decodeLocalState(this.connection,this.tokenBridgeAppId,a);x.length>8&&l.push(new c.AlgorandAddress(x.slice(0,8)).toInt()),o.push({tx:t.makePaymentTxnWithSuggestedParamsFromObject({from:s,to:a,amount:1e5,suggestedParams:r})});let f=new Uint8Array(1);f[0]=1,o.push({tx:t.makeApplicationCallTxnFromObject({appArgs:[g.noop,f],appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),from:s,onComplete:t.OnApplicationComplete.NoOpOC,suggestedParams:r})}),f=new Uint8Array(1),f[0]=2,o.push({tx:t.makeApplicationCallTxnFromObject({appArgs:[g.noop,f],appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),from:s,onComplete:t.OnApplicationComplete.NoOpOC,suggestedParams:r})}),o.push({tx:t.makeApplicationCallTxnFromObject({accounts:[],appArgs:[g.receiveAttest,t.serialize(n)],appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),foreignAssets:l,from:s,onComplete:t.OnApplicationComplete.NoOpOC,suggestedParams:r})}),o[o.length-1].tx.fee=o[o.length-1].tx.fee*2;for(const d of o)yield this.createUnsignedTx(d,"TokenBridge.submitAttestation",!0)}async*transfer(n,e,r,s,i){const a=n.toString(),o=t.isNative(r)?0:new c.AlgorandAddress(r).toInt(),l=s,x=t.toChainId(e.chain),f=e.address.toUniversalAddress().toUint8Array(),d=await this.connection.getTransactionParams().do(),w=BigInt(0),k=p.StorageLogicSig.fromData({appId:this.coreAppId,appAddress:t.decodeAddress(this.coreAppAddress).publicKey,idx:BigInt(0),address:t.decodeAddress(this.tokenBridgeAddress).publicKey}),u=[],{accounts:[m],txs:b}=await p.AlgorandWormholeCore.maybeCreateStorageTx(this.connection,a,this.coreAppId,k,d);u.push(...b);let h="",I,S=!1;if(o!==0){const B=await this.connection.getAssetByID(o).do();h=t.Asset.from_obj_for_encoding(B).params.creator;const O=await this.connection.accountInformation(h).do();I=t.Account.from_obj_for_encoding(O),S=I.authAddr===this.tokenBridgeAddress.toString()}const C=await this.coreBridge.getMessageFee();if(C>0&&u.push({tx:t.makePaymentTxnWithSuggestedParamsFromObject({from:a,to:this.tokenBridgeAddress,amount:C,suggestedParams:d})}),!S){const B=p.StorageLogicSig.forNativeAsset(this.tokenBridgeAppId,BigInt(o)),{accounts:[y],txs:O}=await p.AlgorandWormholeCore.maybeCreateStorageTx(this.connection,a,this.tokenBridgeAppId,B,d);h=y,O.push(...O)}if(o!==0&&!await g.isOptedInToAsset(this.connection,h,o)){const B=t.makePaymentTxnWithSuggestedParamsFromObject({from:a,to:h,amount:1e5,suggestedParams:d});let y=t.makeApplicationCallTxnFromObject({from:a,appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),onComplete:t.OnApplicationComplete.NoOpOC,appArgs:[g.optIn,t.bigIntToBytes(o,8)],foreignAssets:[o],accounts:[h],suggestedParams:d});y.fee*=2,u.unshift({tx:B},{tx:y})}const P=t.makeApplicationCallTxnFromObject({from:a,appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),onComplete:t.OnApplicationComplete.NoOpOC,appArgs:[g.noop],suggestedParams:d});u.push({tx:P});let j=[];if(o===0){const B=t.makePaymentTxnWithSuggestedParamsFromObject({from:a,to:h,amount:l,suggestedParams:d});u.push({tx:B}),j=[m,h,h]}else{const B=t.makeAssetTransferTxnWithSuggestedParamsFromObject({from:a,to:h,amount:l,assetIndex:o,suggestedParams:d});u.push({tx:B}),j=I!=null&&I.address?[m,h,I.address]:[m,h]}const F=[g.sendTransfer,t.bignum.toBytes(o,8),t.bignum.toBytes(l,8),f,t.bignum.toBytes(x,8),t.bignum.toBytes(w,8)];i&&F.push(i);const L=t.makeApplicationCallTxnFromObject({from:a,appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),onComplete:t.OnApplicationComplete.NoOpOC,appArgs:F,foreignApps:[c.safeBigIntToNumber(this.coreAppId)],foreignAssets:[o],accounts:j,suggestedParams:d});L.fee*=2,u.push({tx:L});for(const B of u)yield this.createUnsignedTx(B,"TokenBridge.transfer",!0)}async*redeem(n,e,r=!0,s){s||(s=await this.connection.getTransactionParams().do());const i=new c.AlgorandAddress(n).toString(),{accounts:a,txs:o}=await p.AlgorandWormholeCore.submitVAAHeader(this.connection,this.coreAppId,this.tokenBridgeAppId,e,i);let l,x="",f=[],d=0;if(e.payload.token.chain!==this.chain){l=p.StorageLogicSig.forWrappedAsset(this.tokenBridgeAppId,e.payload.token),x=l.address();const m=await p.StorageLogicSig.decodeLocalState(this.connection,this.tokenBridgeAppId,x);d=new c.AlgorandAddress(m.slice(0,8)).toInt()}else{const m=new c.AlgorandAddress(e.payload.token.address).toBigInt();l=p.StorageLogicSig.forNativeAsset(this.tokenBridgeAppId,m),x=l.address(),d=c.safeBigIntToNumber(m)}a.push(x);let w=0,k="";if(e.payloadName==="TransferWithPayload"?(w=new c.AlgorandAddress(e.payload.to.address).toInt(),k=t.getApplicationAddress(w)):k=new c.AlgorandAddress(e.payload.to.address.toUint8Array()).toString(),a.push(k),d!==0&&(f.push(d),!await g.isOptedInToAsset(this.connection,k,d))){if(i!=k)throw new Error("Cannot ASA optin for somebody else (asset "+d.toString()+")");o.unshift({tx:t.makeAssetTransferTxnWithSuggestedParamsFromObject({amount:0,assetIndex:d,from:i,suggestedParams:s,to:i})})}const u={accounts:a,appArgs:[g.completeTransfer,t.serialize(e)],appIndex:c.safeBigIntToNumber(this.tokenBridgeAppId),foreignAssets:f,from:i,onComplete:t.OnApplicationComplete.NoOpOC,suggestedParams:s};o.push({tx:t.makeApplicationCallTxnFromObject(u)}),o[o.length-1].tx.fee=o[o.length-1].tx.fee*(e.payloadName==="Transfer"&&e.payload.fee!==void 0&&e.payload.fee===0n?2:3),e.payloadName==="TransferWithPayload"&&(o[o.length-1].tx.appForeignApps=[w],o.push({tx:t.makeApplicationCallTxnFromObject({appArgs:[W.getSelector(),W.args[0].type.encode(t.serialize(e))],appIndex:w,foreignAssets:f,from:i,onComplete:t.OnApplicationComplete.NoOpOC,suggestedParams:s})}));for(const m of o)yield this.createUnsignedTx(m,"TokenBridge.redeem",!0)}static async isOptedInToAsset(n,e,r){var s;try{const i=await n.accountAssetInformation(e,r).do();return(((s=t.AccountAssetResponse.from_obj_for_encoding(i).assetHolding)==null?void 0:s.amount)??0)>0}catch{}return!1}createUnsignedTx(n,e,r=!0){return new p.AlgorandUnsignedTransaction(n,this.network,this.chain,e,r)}};A(g,"sendTransfer",t.bytes.encode("sendTransfer")),A(g,"attestToken",t.bytes.encode("attestToken")),A(g,"noop",t.bytes.encode("nop")),A(g,"optIn",t.bytes.encode("optin")),A(g,"completeTransfer",t.bytes.encode("completeTransfer")),A(g,"receiveAttest",t.bytes.encode("receiveAttest"));let N=g;q.registerProtocol(c._platform,"TokenBridge",N);exports.AlgorandTokenBridge=N;exports.TransferMethodSelector=W;

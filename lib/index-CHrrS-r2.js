"use strict";var Ir=Object.defineProperty;var xr=(e,t,r)=>t in e?Ir(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var V=(e,t,r)=>(xr(e,typeof t!="symbol"?t+"":t,r),r);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const B=require("./index-BMvV5qga.js"),S=require("./sui-B9oSGHW_.js");require("./index-De3mKOz1.js");const Ar=require("./chain-DBb0uF1j.js");class _r{constructor(t,r,n,i,s=!1){V(this,"transaction");V(this,"network");V(this,"chain");V(this,"description");V(this,"parallelizable");this.transaction=t,this.network=r,this.chain=n,this.description=i,this.parallelizable=s}}class Cr extends TypeError{constructor(t,r){let n;const{message:i,explanation:s,...o}=t,{path:a}=t,c=a.length===0?i:`At path: ${a.join(".")} -- ${i}`;super(s??c),s!=null&&(this.cause=c),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>n??(n=[t,...r()])}}function Br(e){return K(e)&&typeof e[Symbol.iterator]=="function"}function K(e){return typeof e=="object"&&e!=null}function J(e){return typeof e=="symbol"?e.toString():typeof e=="string"?JSON.stringify(e):`${e}`}function $r(e){const{done:t,value:r}=e.next();return t?void 0:r}function Ur(e,t,r,n){if(e===!0)return;e===!1?e={}:typeof e=="string"&&(e={message:e});const{path:i,branch:s}=t,{type:o}=r,{refinement:a,message:c=`Expected a value of type \`${o}\`${a?` with refinement \`${a}\``:""}, but received: \`${J(n)}\``}=e;return{value:n,type:o,refinement:a,key:i[i.length-1],path:i,branch:s,...e,message:c}}function*Vt(e,t,r,n){Br(e)||(e=[e]);for(const i of e){const s=Ur(i,t,r,n);s&&(yield s)}}function*ut(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:o=!1}=r,a={path:n,branch:i};if(s&&(e=t.coercer(e,a),o&&t.type!=="type"&&K(t.schema)&&K(e)&&!Array.isArray(e)))for(const d in e)t.schema[d]===void 0&&delete e[d];let c="valid";for(const d of t.validator(e,a))d.explanation=r.message,c="not_valid",yield[d,void 0];for(let[d,l,g]of t.entries(e,a)){const m=ut(l,g,{path:d===void 0?n:[...n,d],branch:d===void 0?i:[...i,l],coerce:s,mask:o,message:r.message});for(const y of m)y[0]?(c=y[0].refinement!=null?"not_refined":"not_valid",yield[y[0],void 0]):s&&(l=y[1],d===void 0?e=l:e instanceof Map?e.set(d,l):e instanceof Set?e.add(l):K(e)&&(l!==void 0||d in e)&&(e[d]=l))}if(c!=="not_valid")for(const d of t.refiner(e,a))d.explanation=r.message,c="not_refined",yield[d,void 0];c==="valid"&&(yield[void 0,e])}class te{constructor(t){const{type:r,schema:n,validator:i,refiner:s,coercer:o=c=>c,entries:a=function*(){}}=t;this.type=r,this.schema=n,this.entries=a,this.coercer=o,i?this.validator=(c,d)=>{const l=i(c,d);return Vt(l,d,this,c)}:this.validator=()=>[],s?this.refiner=(c,d)=>{const l=s(c,d);return Vt(l,d,this,c)}:this.refiner=()=>[]}assert(t,r){return tt(t,this,r)}create(t,r){return Kt(t,this,r)}is(t){return L(t,this)}mask(t,r){return Jt(t,this,r)}validate(t,r={}){return Ie(t,this,r)}}function tt(e,t,r){const n=Ie(e,t,{message:r});if(n[0])throw n[0]}function Kt(e,t,r){const n=Ie(e,t,{coerce:!0,message:r});if(n[0])throw n[0];return n[1]}function Jt(e,t,r){const n=Ie(e,t,{coerce:!0,mask:!0,message:r});if(n[0])throw n[0];return n[1]}function L(e,t){return!Ie(e,t)[0]}function Ie(e,t,r={}){const n=ut(e,t,r),i=$r(n);return i[0]?[new Cr(i[0],function*(){for(const o of n)o[0]&&(yield o[0])}),void 0]:[void 0,i[1]]}function je(...e){const t=e[0].type==="type",r=e.map(i=>i.schema),n=Object.assign({},...r);return t?Rr(n):p(n)}function W(e,t){return new te({type:e,schema:null,validator:t})}function rt(){return W("any",()=>!0)}function E(e){return new te({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${J(t)}`}})}function Mr(){return W("bigint",e=>typeof e=="bigint")}function z(){return W("boolean",e=>typeof e=="boolean")}function ee(){return W("integer",e=>typeof e=="number"&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${J(e)}`)}function v(e){const t=J(e),r=typeof e;return new te({type:"literal",schema:r==="string"||r==="number"||r==="boolean"?e:null,validator(n){return n===e||`Expected the literal \`${t}\`, but received: ${J(n)}`}})}function qt(){return W("never",()=>!1)}function $(e){return new te({...e,validator:(t,r)=>t===null||e.validator(t,r),refiner:(t,r)=>t===null||e.refiner(t,r)})}function le(){return W("number",e=>typeof e=="number"&&!isNaN(e)||`Expected a number, but received: ${J(e)}`)}function p(e){const t=e?Object.keys(e):[],r=qt();return new te({type:"object",schema:e||null,*entries(n){if(e&&K(n)){const i=new Set(Object.keys(n));for(const s of t)i.delete(s),yield[s,n[s],e[s]];for(const s of i)yield[s,n[s],r]}},validator(n){return K(n)||`Expected an object, but received: ${J(n)}`},coercer(n){return K(n)?{...n}:n}})}function T(e){return new te({...e,validator:(t,r)=>t===void 0||e.validator(t,r),refiner:(t,r)=>t===void 0||e.refiner(t,r)})}function Q(e,t){return new te({type:"record",schema:null,*entries(r){if(K(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator(r){return K(r)||`Expected an object, but received: ${J(r)}`}})}function h(){return W("string",e=>typeof e=="string"||`Expected a string, but received: ${J(e)}`)}function Ht(e){const t=qt();return new te({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator(r){return Array.isArray(r)||`Expected an array, but received: ${J(r)}`}})}function Rr(e){const t=Object.keys(e);return new te({type:"type",schema:e,*entries(r){if(K(r))for(const n of t)yield[n,r[n],e[n]]},validator(r){return K(r)||`Expected an object, but received: ${J(r)}`},coercer(r){return K(r)?{...r}:r}})}function U(e){const t=e.map(r=>r.type).join(" | ");return new te({type:"union",schema:null,coercer(r){for(const n of e){const[i,s]=n.validate(r,{coerce:!0});if(!i)return s}return r},validator(r,n){const i=[];for(const s of e){const[...o]=ut(r,s,n),[a]=o;if(a[0])for(const[c]of o)c&&i.push(c);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${J(r)}`,...i]}})}function Xt(){return W("unknown",()=>!0)}const dt=U([p({AddressOwner:h()}),p({ObjectOwner:h()}),p({Shared:p({initial_shared_version:$(h())})}),v("Immutable")]);W("SuiJsonValue",()=>!0);const Pr=U([p({u32:h()}),p({u64:h()}),p({f64:h()})]);p({attributes:Q(h(),$(Pr)),featureFlags:Q(h(),z()),maxSupportedProtocolVersion:h(),minSupportedProtocolVersion:h(),protocolVersion:h()});U([h(),v("package")]);const oe=p({digest:h(),objectId:h(),version:U([le(),h(),Mr()])});p({owner:dt,reference:oe});p({objectId:h(),sequenceNumber:h()});p({payment:E(oe),owner:h(),price:h(),budget:h()});const Nr=je(oe,p({type:h(),owner:dt,previousTransaction:h()})),Dr=Q(h(),rt()),zr=Q(h(),Xt()),Vr=p({type:h(),fields:Dr,hasPublicTransfer:z()}),Fr=p({disassembled:zr}),Gr=U([je(Vr,p({dataType:v("moveObject")})),je(Fr,p({dataType:v("package")}))]),Lr=p({type:h(),hasPublicTransfer:z(),version:h(),bcsBytes:h()}),Wr=p({id:h(),moduleMap:Q(h(),h())}),Kr=U([je(Lr,p({dataType:v("moveObject")})),je(Wr,p({dataType:v("package")}))]);BigInt(1e9);const Zt=p({code:h(),error:T(h()),object_id:T(h()),parent_object_id:T(h()),version:T(h()),digest:T(h())}),Jr=p({data:$(T(Q(h(),h()))),error:$(T(Zt))}),qr=U([Jr,T(Q(h(),h()))]),Yt=p({objectId:h(),version:h(),digest:h(),type:$(T(h())),content:$(T(Gr)),bcs:$(T(Kr)),owner:$(T(dt)),previousTransaction:$(T(h())),storageRebate:$(T(h())),display:$(T(qr))});p({showType:$(T(z())),showContent:$(T(z())),showBcs:$(T(z())),showOwner:$(T(z())),showPreviousTransaction:$(T(z())),showStorageRebate:$(T(z())),showDisplay:$(T(z()))});U([v("Exists"),v("notExists"),v("Deleted")]);E(Nr);const Hr=p({data:$(T(Yt)),error:$(T(Zt))});function Xr(e){return e.data}function Zr(e){if(e.error&&"object_id"in e.error&&"version"in e.error&&"digest"in e.error){const t=e.error;return{objectId:t.object_id,version:t.version,digest:t.digest}}}function Ft(e){if("reference"in e)return e.reference;const t=Xr(e);return t?{objectId:t.objectId,version:t.version,digest:t.digest}:Zr(e)}p({objectId:h(),atCheckpoint:T(le())});p({data:E(Hr),nextCursor:T($(h())),hasNextPage:z()});U([p({details:Yt,status:v("VersionFound")}),p({details:h(),status:v("ObjectNotExists")}),p({details:oe,status:v("ObjectDeleted")}),p({details:Ht([h(),le()]),status:v("VersionNotFound")}),p({details:p({asked_version:le(),latest_version:le(),object_id:h()}),status:v("VersionTooHigh")})]);const Yr=U([h(),p({Object:h()})]);E(Yr);const Qr=p({address:h(),name:h()}),en=U([v("Private"),v("Public"),v("Friend")]),lt=p({abilities:E(h())}),tn=p({constraints:lt,isPhantom:z()}),rn=p({TypeParameter:le()}),qe=Ht([p({module:h(),package:h(),function:h()}),h()]);p({rank3Days:E(qe),rank7Days:E(qe),rank30Days:E(qe)});function Qt(e){if(!e)return!1;if(typeof e=="string"||L(e,rn)||er(e))return!0;if(typeof e!="object")return!1;const t=e;return!!(L(t.Reference,pe)||L(t.MutableReference,pe)||L(t.Vector,pe))}const pe=W("SuiMoveNormalizedType",Qt);function er(e){if(!e||typeof e!="object")return!1;const t=e;if(!t.Struct||typeof t.Struct!="object")return!1;const r=t.Struct;return!(typeof r.address!="string"||typeof r.module!="string"||typeof r.name!="string"||!Array.isArray(r.typeArguments)||!r.typeArguments.every(n=>Qt(n)))}W("SuiMoveNormalizedStructType",er);const nn=p({visibility:en,isEntry:z(),typeParameters:E(lt),parameters:E(pe),return:E(pe)}),sn=p({name:h(),type:pe}),an=p({abilities:lt,typeParameters:E(tn),fields:E(sn)}),on=p({fileFormatVersion:le(),address:h(),name:h(),friends:E(Qr),structs:Q(h(),an),exposedFunctions:Q(h(),nn)});Q(h(),on);function nt(e){return typeof e=="object"&&"MutableReference"in e?e.MutableReference:void 0}function tr(e){return typeof e=="object"&&"Reference"in e?e.Reference:void 0}function ft(e){if(typeof e=="object"&&"Struct"in e)return e;const t=tr(e),r=nt(e);if(typeof t=="object"&&"Struct"in t)return t;if(typeof r=="object"&&"Struct"in r)return r}function cn(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(t[s]!==255)throw new TypeError(i+" is ambiguous");t[s]=n}var o=e.length,a=e.charAt(0),c=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function l(y){if(y instanceof Uint8Array||(ArrayBuffer.isView(y)?y=new Uint8Array(y.buffer,y.byteOffset,y.byteLength):Array.isArray(y)&&(y=Uint8Array.from(y))),!(y instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(y.length===0)return"";for(var w=0,b=0,f=0,x=y.length;f!==x&&y[f]===0;)f++,w++;for(var C=(x-f)*d+1>>>0,P=new Uint8Array(C);f!==x;){for(var A=y[f],k=0,N=C-1;(A!==0||k<b)&&N!==-1;N--,k++)A+=256*P[N]>>>0,P[N]=A%o>>>0,A=A/o>>>0;if(A!==0)throw new Error("Non-zero carry");b=k,f++}for(var q=C-b;q!==C&&P[q]===0;)q++;for(var he=a.repeat(w);q<C;++q)he+=e.charAt(P[q]);return he}function g(y){if(typeof y!="string")throw new TypeError("Expected String");if(y.length===0)return new Uint8Array;for(var w=0,b=0,f=0;y[w]===a;)b++,w++;for(var x=(y.length-w)*c+1>>>0,C=new Uint8Array(x);y[w];){var P=t[y.charCodeAt(w)];if(P===255)return;for(var A=0,k=x-1;(P!==0||A<f)&&k!==-1;k--,A++)P+=o*C[k]>>>0,C[k]=P%256>>>0,P=P/256>>>0;if(P!==0)throw new Error("Non-zero carry");f=A,w++}for(var N=x-f;N!==x&&C[N]===0;)N++;for(var q=new Uint8Array(b+(x-N)),he=b;N!==x;)q[he++]=C[N++];return q}function m(y){var w=g(y);if(w)return w;throw new Error("Non-base"+o+" character")}return{encode:l,decodeUnsafe:g,decode:m}}var un=cn;const dn=un,ln="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var fn=dn(ln);const rr=B.getDefaultExportFromCjs(fn),xe=e=>rr.encode(e),ht=e=>rr.decode(e);function ce(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))}const He=8192;function Ae(e){if(e.length<He)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=He){const n=e.slice(r,r+He);t+=String.fromCharCode(...n)}return btoa(t)}function Ke(e){var i;const t=e.startsWith("0x")?e.slice(2):e,n=((i=(t.length%2===0?t:`0${t}}`).match(/.{2}/g))==null?void 0:i.map(s=>parseInt(s,16)))??[];return Uint8Array.from(n)}function _e(e){return e.reduce((t,r)=>t+r.toString(16).padStart(2,"0"),"")}function gt(e){let t=[],r=0;if(e===0)return[0];for(;e>0;)t[r]=e&127,(e>>=7)&&(t[r]|=128),r+=1;return t}function hn(e){let t=0,r=0,n=0;for(;;){let i=e[n];if(n+=1,t|=(i&127)<<r,!(i&128))break;r+=7}return{value:t,length:n}}class nr{constructor(t){this.bytePosition=0,this.dataView=new DataView(t.buffer)}shift(t){return this.bytePosition+=t,this}read8(){let t=this.dataView.getUint8(this.bytePosition);return this.shift(1),t}read16(){let t=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),t}read32(){let t=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),t}read64(){let t=this.read32(),n=this.read32().toString(16)+t.toString(16).padStart(8,"0");return BigInt("0x"+n).toString(10)}read128(){let t=BigInt(this.read64()),n=BigInt(this.read64()).toString(16)+t.toString(16).padStart(16,"0");return BigInt("0x"+n).toString(10)}read256(){let t=BigInt(this.read128()),n=BigInt(this.read128()).toString(16)+t.toString(16).padStart(32,"0");return BigInt("0x"+n).toString(10)}readBytes(t){let r=this.bytePosition+this.dataView.byteOffset,n=new Uint8Array(this.dataView.buffer,r,t);return this.shift(t),n}readULEB(){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t),{value:n,length:i}=hn(r);return this.shift(i),n}readVec(t){let r=this.readULEB(),n=[];for(let i=0;i<r;i++)n.push(t(this,i,r));return n}}function gn(e,t){switch(t){case"base58":return xe(e);case"base64":return Ae(e);case"hex":return _e(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function pn(e,t){switch(t){case"base58":return ht(e);case"base64":return ce(e);case"hex":return Ke(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function ir(e,t=["<",">"]){const[r,n]=t,i=[];let s="",o=0;for(let a=0;a<e.length;a++){const c=e[a];if(c===r&&o++,c===n&&o--,o===0&&c===","){i.push(s.trim()),s="";continue}s+=c}return i.push(s.trim()),i}class sr{constructor({size:t=1024,maxSize:r,allocateSize:n=1024}={}){this.bytePosition=0,this.size=t,this.maxSize=r||t,this.allocateSize=n,this.dataView=new DataView(new ArrayBuffer(t))}ensureSizeOrGrow(t){const r=this.bytePosition+t;if(r>this.size){const n=Math.min(this.maxSize,this.size+this.allocateSize);if(r>n)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r}`);this.size=n;const i=new ArrayBuffer(this.size);new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(i)}}shift(t){return this.bytePosition+=t,this}write8(t){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(t)),this.shift(1)}write16(t){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(t),!0),this.shift(2)}write32(t){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(t),!0),this.shift(4)}write64(t){return Xe(BigInt(t),8).forEach(r=>this.write8(r)),this}write128(t){return Xe(BigInt(t),16).forEach(r=>this.write8(r)),this}write256(t){return Xe(BigInt(t),32).forEach(r=>this.write8(r)),this}writeULEB(t){return gt(t).forEach(r=>this.write8(r)),this}writeVec(t,r){return this.writeULEB(t.length),Array.from(t).forEach((n,i)=>r(this,n,i,t.length)),this}*[Symbol.iterator](){for(let t=0;t<this.bytePosition;t++)yield this.dataView.getUint8(t);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(t){return gn(this.toBytes(),t)}}function Xe(e,t){let r=new Uint8Array(t),n=0;for(;e>0;)r[n]=Number(e%BigInt(256)),e=e/BigInt(256),n+=1;return r}var ar=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},X=(e,t,r)=>(ar(e,t,"read from private field"),r?r.call(e):t.get(e)),ze=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Ve=(e,t,r,n)=>(ar(e,t,"write to private field"),t.set(e,r),r),ge,be,Me,ae;const or=class{constructor(e){ze(this,ge,void 0),ze(this,be,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),Ve(this,ge,e.write),Ve(this,be,e.serialize??((t,r)=>{const n=new sr({size:this.serializedSize(t)??void 0,...r});return X(this,ge).call(this,t,n),n.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),X(this,ge).call(this,e,t)}serialize(e,t){return this.validate(e),new yn(this,X(this,be).call(this,e,t))}parse(e){const t=new nr(e);return this.read(t)}transform({name:e,input:t,output:r}){return new or({name:e??this.name,read:n=>r(this.read(n)),write:(n,i)=>X(this,ge).call(this,t(n),i),serializedSize:n=>this.serializedSize(t(n)),serialize:(n,i)=>X(this,be).call(this,t(n),i),validate:n=>this.validate(t(n))})}};let Z=or;ge=new WeakMap;be=new WeakMap;const cr=Symbol.for("@mysten/serialized-bcs");function pt(e){return!!e&&typeof e=="object"&&e[cr]===!0}class yn{constructor(t,r){ze(this,Me,void 0),ze(this,ae,void 0),Ve(this,Me,t),Ve(this,ae,r)}get[cr](){return!0}toBytes(){return X(this,ae)}toHex(){return _e(X(this,ae))}toBase64(){return Ae(X(this,ae))}toBase58(){return xe(X(this,ae))}parse(){return X(this,Me).parse(X(this,ae))}}Me=new WeakMap;ae=new WeakMap;function Fe({size:e,...t}){return new Z({...t,serializedSize:()=>e})}function Ze({readMethod:e,writeMethod:t,...r}){return Fe({...r,read:n=>n[e](),write:(n,i)=>i[t](n),validate:n=>{var i;if(n<0||n>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${n}. Expected value in range 0-${r.maxValue}`);(i=r.validate)==null||i.call(r,n)}})}function Ye({readMethod:e,writeMethod:t,...r}){return Fe({...r,read:n=>n[e](),write:(n,i)=>i[t](BigInt(n)),validate:n=>{var s;const i=BigInt(n);if(i<0||i>r.maxValue)throw new TypeError(`Invalid ${r.name} value: ${i}. Expected value in range 0-${r.maxValue}`);(s=r.validate)==null||s.call(r,i)}})}function mn({serialize:e,...t}){const r=new Z({...t,serialize:e,write:(n,i)=>{for(const s of r.serialize(n).toBytes())i.write8(s)}});return r}function wn({toBytes:e,fromBytes:t,...r}){return new Z({...r,read:n=>{const i=n.readULEB(),s=n.readBytes(i);return t(s)},write:(n,i)=>{const s=e(n);i.writeULEB(s.length);for(let o=0;o<s.length;o++)i.write8(s[o])},serialize:n=>{const i=e(n),s=gt(i.length),o=new Uint8Array(s.length+i.length);return o.set(s,0),o.set(i,s.length),o},validate:n=>{var i;if(typeof n!="string")throw new TypeError(`Invalid ${r.name} value: ${n}. Expected string`);(i=r.validate)==null||i.call(r,n)}})}function bn(e){let t=null;function r(){return t||(t=e()),t}return new Z({name:"lazy",read:n=>r().read(n),serializedSize:n=>r().serializedSize(n),write:(n,i)=>r().write(n,i),serialize:(n,i)=>r().serialize(n,i).toBytes()})}const u={u8(e){return Ze({name:"u8",readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...e})},u16(e){return Ze({name:"u16",readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...e})},u32(e){return Ze({name:"u32",readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...e})},u64(e){return Ye({name:"u64",readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...e})},u128(e){return Ye({name:"u128",readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...e})},u256(e){return Ye({name:"u256",readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...e})},bool(e){return Fe({name:"bool",size:1,read:t=>t.read8()===1,write:(t,r)=>r.write8(t?1:0),...e,validate:t=>{var r;if((r=e==null?void 0:e.validate)==null||r.call(e,t),typeof t!="boolean")throw new TypeError(`Expected boolean, found ${typeof t}`)}})},uleb128(e){return mn({name:"uleb128",read:t=>t.readULEB(),serialize:t=>Uint8Array.from(gt(t)),...e})},bytes(e,t){return Fe({name:`bytes[${e}]`,size:e,read:r=>r.readBytes(e),write:(r,n)=>{for(let i=0;i<e;i++)n.write8(r[i]??0)},...t,validate:r=>{var n;if((n=t==null?void 0:t.validate)==null||n.call(t,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==e)throw new TypeError(`Expected array of length ${e}, found ${r.length}`)}})},string(e){return wn({name:"string",toBytes:t=>new TextEncoder().encode(t),fromBytes:t=>new TextDecoder().decode(t),...e})},fixedArray(e,t,r){return new Z({name:`${t.name}[${e}]`,read:n=>{const i=new Array(e);for(let s=0;s<e;s++)i[s]=t.read(n);return i},write:(n,i)=>{for(const s of n)t.write(s,i)},...r,validate:n=>{var i;if((i=r==null?void 0:r.validate)==null||i.call(r,n),!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`);if(n.length!==e)throw new TypeError(`Expected array of length ${e}, found ${n.length}`)}})},option(e){return u.enum(`Option<${e.name}>`,{None:null,Some:e}).transform({input:t=>t==null?{None:!0}:{Some:t},output:t=>"Some"in t?t.Some:null})},vector(e,t){return new Z({name:`vector<${e.name}>`,read:r=>{const n=r.readULEB(),i=new Array(n);for(let s=0;s<n;s++)i[s]=e.read(r);return i},write:(r,n)=>{n.writeULEB(r.length);for(const i of r)e.write(i,n)},...t,validate:r=>{var n;if((n=t==null?void 0:t.validate)==null||n.call(t,r),!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`)}})},tuple(e,t){return new Z({name:`(${e.map(r=>r.name).join(", ")})`,serializedSize:r=>{let n=0;for(let i=0;i<e.length;i++){const s=e[i].serializedSize(r[i]);if(s==null)return null;n+=s}return n},read:r=>{const n=[];for(const i of e)n.push(i.read(r));return n},write:(r,n)=>{for(let i=0;i<e.length;i++)e[i].write(r[i],n)},...t,validate:r=>{var n;if((n=t==null?void 0:t.validate)==null||n.call(t,r),!Array.isArray(r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`)}})},struct(e,t,r){const n=Object.entries(t);return new Z({name:e,serializedSize:i=>{let s=0;for(const[o,a]of n){const c=a.serializedSize(i[o]);if(c==null)return null;s+=c}return s},read:i=>{const s={};for(const[o,a]of n)s[o]=a.read(i);return s},write:(i,s)=>{for(const[o,a]of n)a.write(i[o],s)},...r,validate:i=>{var s;if((s=r==null?void 0:r.validate)==null||s.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})},enum(e,t,r){const n=Object.entries(t);return new Z({name:e,read:i=>{const s=i.readULEB(),[o,a]=n[s];return{[o]:(a==null?void 0:a.read(i))??!0}},write:(i,s)=>{const[o,a]=Object.entries(i)[0];for(let c=0;c<n.length;c++){const[d,l]=n[c];if(d===o){s.writeULEB(c),l==null||l.write(a,s);return}}},...r,validate:i=>{var a;if((a=r==null?void 0:r.validate)==null||a.call(r,i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`);const s=Object.keys(i);if(s.length!==1)throw new TypeError(`Expected object with one key, found ${s.length}`);const[o]=s;if(!Object.hasOwn(t,o))throw new TypeError(`Invalid enum variant ${o}`)}})},map(e,t){return u.vector(u.tuple([e,t])).transform({name:`Map<${e.name}, ${t.name}>`,input:r=>[...r.entries()],output:r=>{const n=new Map;for(const[i,s]of r)n.set(i,s);return n}})},generic(e,t){return(...r)=>t(...r).transform({name:`${t.name}<${r.map(n=>n.name).join(", ")}>`,input:n=>n,output:n=>n})},lazy(e){return bn(e)}},Sn=32,Se=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof Se){this.schema=e.schema,this.types=new Map(e.types);return}if(this.schema=e,this.registerAddressType(Se.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);e.withPrimitives!==!1&&Tn(this)}tempKey(){return`bcs-struct-${++this.counter}`}ser(e,t,r){if(typeof e=="string"||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).encode(this,t,r,i)}if(typeof e=="object"){const n=this.tempKey();return new Se(this).registerStructType(n,e).ser(n,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. 
${JSON.stringify(e)}`)}de(e,t,r){if(typeof t=="string")if(r)t=pn(t,r);else throw new Error("To pass a string to `bcs.de`, specify encoding");if(typeof e=="string"||Array.isArray(e)){const{name:n,params:i}=this.parseTypeName(e);return this.getTypeInterface(n).decode(this,t,i)}if(typeof e=="object"){const n=new Se(this),i=this.tempKey();return n.registerStructType(i,e).de(i,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. 
${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,n=()=>!0){const{name:i,params:s}=this.parseTypeName(e);return this.types.set(i,{encode(o,a,c,d){const l=s.reduce((g,m,y)=>Object.assign(g,{[m]:d[y]}),{});return this._encodeRaw.call(o,new sr(c),a,d,l)},decode(o,a,c){const d=s.reduce((l,g,m)=>Object.assign(l,{[g]:c[m]}),{});return this._decodeRaw.call(o,new nr(a),c,d)},_encodeRaw(o,a,c,d){if(n(a))return t.call(this,o,a,c,d);throw new Error(`Validation failed for type ${i}, data: ${a}`)},_decodeRaw(o,a,c){return r.call(this,o,a,c)}}),this}registerBcsType(e,t){return this.registerType(e,(r,n,i)=>{const s=i.map(o=>new Z({name:String(o),write:(a,c)=>{const{name:d,params:l}=this.parseTypeName(o),g=this.getTypeInterface(d),m=l.reduce((y,w,b)=>Object.assign(y,{[w]:i[b]}),{});return g._encodeRaw.call(this,c,a,l,m)},read:()=>{throw new Error("Not implemented")}}));return t(...s).write(n,r),r},(r,n)=>{const i=n.map(s=>new Z({name:String(s),write:(o,a)=>{throw new Error("Not implemented")},read:o=>{const{name:a,params:c}=this.parseTypeName(s),d=this.getTypeInterface(a),l=c.reduce((g,m,y)=>Object.assign(g,{[m]:n[y]}),{});return d._decodeRaw.call(this,o,c,l)}}));return t(...i).read(r)}),this}registerAddressType(e,t,r="hex"){switch(r){case"base64":return this.registerType(e,function(i,s){return ce(s).reduce((o,a)=>o.write8(a),i)},function(i){return Ae(i.readBytes(t))});case"hex":return this.registerType(e,function(i,s){return Ke(s).reduce((o,a)=>o.write8(a),i)},function(i){return _e(i.readBytes(t))});default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,function(i,s,o,a){return i.writeVec(s,(c,d)=>{let l=o[0];if(!l)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:g,params:m}=this.parseTypeName(l);if(this.hasType(g))return this.getTypeInterface(g)._encodeRaw.call(this,c,d,m,a);if(!(g in a))throw new Error(`Unable to find a matching type definition for ${g} in vector; make sure you passed a generic`);let{name:y,params:w}=this.parseTypeName(a[g]);return this.getTypeInterface(y)._encodeRaw.call(this,c,d,w,a)})},function(i,s,o){return i.readVec(a=>{let c=s[0];if(!c)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:d,params:l}=this.parseTypeName(c);if(this.hasType(d))return this.getTypeInterface(d)._decodeRaw.call(this,a,l,o);if(!(d in o))throw new Error(`Unable to find a matching type definition for ${d} in vector; make sure you passed a generic`);let{name:g,params:m}=this.parseTypeName(o[d]);return this.getTypeInterface(g)._decodeRaw.call(this,a,m,o)})})}registerStructType(e,t){for(let o in t){let a=this.tempKey(),c=t[o];!Array.isArray(c)&&typeof c!="string"&&(t[o]=a,this.registerStructType(a,c))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,function(a,c,d,l){if(!c||c.constructor!==Object)throw new Error(`Expected ${i} to be an Object, got: ${c}`);if(d.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${d.length}`);for(let g of n){if(!(g in c))throw new Error(`Struct ${i} requires field ${g}:${r[g]}`);const{name:m,params:y}=this.parseTypeName(r[g]);if(!s.includes(m))this.getTypeInterface(m)._encodeRaw.call(this,a,c[g],y,l);else{const w=s.indexOf(m);let{name:b,params:f}=this.parseTypeName(d[w]);if(this.hasType(b)){this.getTypeInterface(b)._encodeRaw.call(this,a,c[g],f,l);continue}if(!(b in l))throw new Error(`Unable to find a matching type definition for ${b} in ${i}; make sure you passed a generic`);let{name:x,params:C}=this.parseTypeName(l[b]);this.getTypeInterface(x)._encodeRaw.call(this,a,c[g],C,l)}}return a},function(a,c,d){if(c.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${c.length}`);let l={};for(let g of n){const{name:m,params:y}=this.parseTypeName(r[g]);if(!s.includes(m))l[g]=this.getTypeInterface(m)._decodeRaw.call(this,a,y,d);else{const w=s.indexOf(m);let{name:b,params:f}=this.parseTypeName(c[w]);if(this.hasType(b)){l[g]=this.getTypeInterface(b)._decodeRaw.call(this,a,f,d);continue}if(!(b in d))throw new Error(`Unable to find a matching type definition for ${b} in ${i}; make sure you passed a generic`);let{name:x,params:C}=this.parseTypeName(d[b]);l[g]=this.getTypeInterface(x)._decodeRaw.call(this,a,C,d)}}return l})}registerEnumType(e,t){for(let o in t){let a=this.tempKey(),c=t[o];c!==null&&!Array.isArray(c)&&typeof c!="string"&&(t[o]=a,this.registerStructType(a,c))}let r=Object.freeze(t),n=Object.keys(r),{name:i,params:s}=this.parseTypeName(e);return this.registerType(e,function(a,c,d,l){if(!c)throw new Error(`Unable to write enum "${i}", missing data.
Received: "${c}"`);if(typeof c!="object")throw new Error(`Incorrect data passed into enum "${i}", expected object with properties: "${n.join(" | ")}".
Received: "${JSON.stringify(c)}"`);let g=Object.keys(c)[0];if(g===void 0)throw new Error(`Empty object passed as invariant of the enum "${i}"`);let m=n.indexOf(g);if(m===-1)throw new Error(`Unknown invariant of the enum "${i}", allowed values: "${n.join(" | ")}"; received "${g}"`);let y=n[m],w=r[y];if(a.write8(m),w===null)return a;let b=s.indexOf(w),f=b===-1?w:d[b];{let{name:x,params:C}=this.parseTypeName(f);return this.getTypeInterface(x)._encodeRaw.call(this,a,c[g],C,l)}},function(a,c,d){let l=a.readULEB(),g=n[l],m=r[g];if(l===-1)throw new Error(`Decoding type mismatch, expected enum "${i}" invariant index, received "${l}"`);if(m===null)return{[g]:!0};let y=s.indexOf(m),w=y===-1?m:c[y];{let{name:b,params:f}=this.parseTypeName(w);return{[g]:this.getTypeInterface(b)._decodeRaw.call(this,a,f,d)}}})}getTypeInterface(e){let t=this.types.get(e);if(typeof t=="string"){let r=[];for(;typeof t=="string";){if(r.includes(t))throw new Error(`Recursive definition found: ${r.join(" -> ")} -> ${t}`);r.push(t),t=this.types.get(t)}}if(t===void 0)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[a,...c]=e;return{name:a,params:c}}if(typeof e!="string")throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],n=e.indexOf(t),i=Array.from(e).reverse().indexOf(r);if(n===-1&&i===-1)return{name:e,params:[]};if(n===-1||i===-1)throw new Error(`Unclosed generic in name '${e}'`);let s=e.slice(0,n),o=ir(e.slice(n+1,e.length-i-1),this.schema.genericSeparators);return{name:s,params:o}}};let _=Se;_.U8="u8";_.U16="u16";_.U32="u32";_.U64="u64";_.U128="u128";_.U256="u256";_.BOOL="bool";_.VECTOR="vector";_.ADDRESS="address";_.STRING="string";_.HEX="hex-string";_.BASE58="base58-string";_.BASE64="base64-string";function Tn(e){e.registerType(_.U8,function(t,r){return t.write8(r)},function(t){return t.read8()},t=>t<256),e.registerType(_.U16,function(t,r){return t.write16(r)},function(t){return t.read16()},t=>t<65536),e.registerType(_.U32,function(t,r){return t.write32(r)},function(t){return t.read32()},t=>t<=4294967296n),e.registerType(_.U64,function(t,r){return t.write64(r)},function(t){return t.read64()}),e.registerType(_.U128,function(t,r){return t.write128(r)},function(t){return t.read128()}),e.registerType(_.U256,function(t,r){return t.write256(r)},function(t){return t.read256()}),e.registerType(_.BOOL,function(t,r){return t.write8(r)},function(t){return t.read8().toString(10)==="1"}),e.registerType(_.STRING,function(t,r){return t.writeVec(Array.from(r),(n,i)=>n.write8(i.charCodeAt(0)))},function(t){return t.readVec(r=>r.read8()).map(r=>String.fromCharCode(Number(r))).join("")},t=>!0),e.registerType(_.HEX,function(t,r){return t.writeVec(Array.from(Ke(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return _e(new Uint8Array(r))}),e.registerType(_.BASE58,function(t,r){return t.writeVec(Array.from(ht(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return xe(new Uint8Array(r))}),e.registerType(_.BASE64,function(t,r){return t.writeVec(Array.from(ce(r)),(n,i)=>n.write8(i))},function(t){let r=t.readVec(n=>n.read8());return Ae(new Uint8Array(r))})}function vn(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:Sn,addressEncoding:"hex"}}const yt=32;function jn(e){return En(e)&&kn(e)===yt}function D(e,t=!1){let r=e.toLowerCase();return!t&&r.startsWith("0x")&&(r=r.slice(2)),`0x${r.padStart(yt*2,"0")}`}function ye(e,t=!1){return D(e,t)}function En(e){return/^(0x|0X)?[a-fA-F0-9]+$/.test(e)&&e.length%2===0}function kn(e){return/^(0x|0X)/.test(e)?(e.length-2)/2:e.length/2}BigInt(1e9);const mt="0x1",ur="0x2",we=ye("0x6"),Re=`${ur}::sui::SUI`;ye("0x5");const On="object",In="ID",xn="ascii",An="String",_n="string",Cn="String",Bn="option",$n="Option",Un={address:ur,module:On,name:In},Mn={address:mt,module:xn,name:An},Rn={address:mt,module:_n,name:Cn},Pn={address:mt,module:Bn,name:$n},Ce=(e,t)=>e.address===t.address&&e.module===t.module&&e.name===t.name;function Nn(e){var r;const t=(r=ft(e))==null?void 0:r.Struct;return(t==null?void 0:t.address)==="0x2"&&(t==null?void 0:t.module)==="tx_context"&&(t==null?void 0:t.name)==="TxContext"}function Qe(e,t){if(!(typeof t>"u")&&typeof t!==e)throw new Error(`Expect ${t} to be ${e}, received ${typeof t}`)}const Dn=["Address","Bool","U8","U16","U32","U64","U128","U256"];function it(e,t){if(typeof e=="string"&&Dn.includes(e)){if(e in["U8","U16","U32","U64","U128","U256"])Qe("number",t);else if(e==="Bool")Qe("boolean",t);else if(e==="Address"&&(Qe("string",t),t&&!jn(t)))throw new Error("Invalid Sui Address");return e.toLowerCase()}else if(typeof e=="string")throw new Error(`Unknown pure normalized type ${JSON.stringify(e,null,2)}`);if("Vector"in e){if((t===void 0||typeof t=="string")&&e.Vector==="U8")return"string";if(t!==void 0&&!Array.isArray(t))throw new Error(`Expect ${t} to be a array, received ${typeof t}`);const r=it(e.Vector,t?t[0]:void 0);return r===void 0?void 0:`vector<${r}>`}if("Struct"in e){if(Ce(e.Struct,Mn))return"string";if(Ce(e.Struct,Rn))return"utf8string";if(Ce(e.Struct,Un))return"address";if(Ce(e.Struct,Pn)){const r={Vector:e.Struct.typeArguments[0]};return it(r,t)}}}const zn=/^vector<(.+)>$/,Vn=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class ne{static parseFromStr(t,r=!1){if(t==="address")return{address:null};if(t==="bool")return{bool:null};if(t==="u8")return{u8:null};if(t==="u16")return{u16:null};if(t==="u32")return{u32:null};if(t==="u64")return{u64:null};if(t==="u128")return{u128:null};if(t==="u256")return{u256:null};if(t==="signer")return{signer:null};const n=t.match(zn);if(n)return{vector:ne.parseFromStr(n[1],r)};const i=t.match(Vn);if(i)return{struct:{address:r?D(i[1]):i[1],module:i[2],name:i[3],typeParams:i[5]===void 0?[]:ne.parseStructTypeArgs(i[5],r)}};throw new Error(`Encountered unexpected token when parsing type args for ${t}`)}static parseStructTypeArgs(t,r=!1){return ir(t).map(n=>ne.parseFromStr(n,r))}static tagToString(t){if("bool"in t)return"bool";if("u8"in t)return"u8";if("u16"in t)return"u16";if("u32"in t)return"u32";if("u64"in t)return"u64";if("u128"in t)return"u128";if("u256"in t)return"u256";if("address"in t)return"address";if("signer"in t)return"signer";if("vector"in t)return`vector<${ne.tagToString(t.vector)}>`;if("struct"in t){const r=t.struct,n=r.typeParams.map(ne.tagToString).join(", ");return`${r.address}::${r.module}::${r.name}${n?`<${n}>`:""}`}throw new Error("Invalid TypeTag")}}const I=new _({...vn(),types:{enums:{"Option<T>":{None:null,Some:"T"}}}});function dr(e){return u.u64({name:"unsafe_u64",...e}).transform({input:t=>t,output:t=>Number(t)})}function Fn(e){return u.enum("Option",{None:null,Some:e})}function wt(e){return e.transform({input:t=>({[t.kind]:t}),output:t=>{const r=Object.keys(t)[0];return{kind:r,...t[r]}}})}const Y=u.bytes(yt).transform({input:e=>typeof e=="string"?Ke(D(e)):e,output:e=>D(_e(e))}),bt=u.vector(u.u8()).transform({name:"ObjectDigest",input:e=>ht(e),output:e=>xe(new Uint8Array(e))}),Ee=u.struct("SuiObjectRef",{objectId:Y,version:u.u64(),digest:bt}),St=u.struct("SharedObjectRef",{objectId:Y,initialSharedVersion:u.u64(),mutable:u.bool()}),Ge=u.enum("ObjectArg",{ImmOrOwned:Ee,Shared:St,Receiving:Ee}),Tt=u.enum("CallArg",{Pure:u.vector(u.u8()),Object:Ge,ObjVec:u.vector(Ge)}),me=u.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:u.lazy(()=>me),struct:u.lazy(()=>It),u16:null,u32:null,u256:null}),H=wt(u.enum("Argument",{GasCoin:null,Input:u.struct("Input",{index:u.u16()}),Result:u.struct("Result",{index:u.u16()}),NestedResult:u.struct("NestedResult",{index:u.u16(),resultIndex:u.u16()})})),vt=u.struct("ProgrammableMoveCall",{package:Y,module:u.string(),function:u.string(),type_arguments:u.vector(me),arguments:u.vector(H)}).transform({input:e=>{const[t,r,n]=e.target.split("::"),i=e.typeArguments.map(s=>ne.parseFromStr(s,!0));return{package:D(t),module:r,function:n,type_arguments:i,arguments:e.arguments}},output:e=>({target:[e.package,e.module,e.function].join("::"),arguments:e.arguments,typeArguments:e.type_arguments.map(ne.tagToString)})}),jt=wt(u.enum("Transaction",{MoveCall:vt,TransferObjects:u.struct("TransferObjects",{objects:u.vector(H),address:H}),SplitCoins:u.struct("SplitCoins",{coin:H,amounts:u.vector(H)}),MergeCoins:u.struct("MergeCoins",{destination:H,sources:u.vector(H)}),Publish:u.struct("Publish",{modules:u.vector(u.vector(u.u8())),dependencies:u.vector(Y)}),MakeMoveVec:u.struct("MakeMoveVec",{type:Fn(me),objects:u.vector(H)}),Upgrade:u.struct("Upgrade",{modules:u.vector(u.vector(u.u8())),dependencies:u.vector(Y),packageId:Y,ticket:H})})),Et=u.struct("ProgrammableTransaction",{inputs:u.vector(Tt),transactions:u.vector(jt)}),kt=u.enum("TransactionKind",{ProgrammableTransaction:Et,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),Ot=u.enum("TransactionExpiration",{None:null,Epoch:dr()}),It=u.struct("StructTag",{address:Y,module:u.string(),name:u.string(),typeParams:u.vector(me)}),xt=u.struct("GasData",{payment:u.vector(Ee),owner:Y,price:u.u64(),budget:u.u64()}),At=u.struct("TransactionDataV1",{kind:kt,sender:Y,gasData:xt,expiration:Ot}),_t=u.enum("TransactionData",{V1:At}),Gn=u.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),Ln=u.enum("IntentVersion",{V0:null}),Wn=u.enum("AppId",{Sui:null}),Kn=u.struct("Intent",{scope:Gn,version:Ln,appId:Wn}),Jn=u.generic(["T"],e=>u.struct("IntentMessage<T>",{intent:Kn,value:e})),Ct=u.enum("CompressedSignature",{ED25519:u.fixedArray(64,u.u8()),Secp256k1:u.fixedArray(64,u.u8()),Secp256r1:u.fixedArray(64,u.u8()),ZkLogin:u.vector(u.u8())}),Bt=u.enum("PublicKey",{ED25519:u.fixedArray(32,u.u8()),Secp256k1:u.fixedArray(33,u.u8()),Secp256r1:u.fixedArray(33,u.u8()),ZkLogin:u.vector(u.u8())}),$t=u.struct("MultiSigPkMap",{pubKey:Bt,weight:u.u8()}),Ut=u.struct("MultiSigPublicKey",{pk_map:u.vector($t),threshold:u.u16()}),lr=u.struct("MultiSig",{sigs:u.vector(Ct),bitmap:u.u16(),multisig_pk:Ut}),qn=u.vector(u.u8()).transform({input:e=>typeof e=="string"?ce(e):e,output:e=>Ae(new Uint8Array(e))}),fr=u.struct("SenderSignedTransaction",{intentMessage:Jn(_t),txSignatures:u.vector(qn)}),hr=u.vector(fr,{name:"SenderSignedData"}),M={...u,U8:u.u8(),U16:u.u16(),U32:u.u32(),U64:u.u64(),U128:u.u128(),U256:u.u256(),ULEB128:u.uleb128(),Bool:u.bool(),String:u.string(),Address:Y,Argument:H,CallArg:Tt,CompressedSignature:Ct,GasData:xt,MultiSig:lr,MultiSigPkMap:$t,MultiSigPublicKey:Ut,ObjectArg:Ge,ObjectDigest:bt,ProgrammableMoveCall:vt,ProgrammableTransaction:Et,PublicKey:Bt,SenderSignedData:hr,SenderSignedTransaction:fr,SharedObjectRef:St,StructTag:It,SuiObjectRef:Ee,Transaction:jt,TransactionData:_t,TransactionDataV1:At,TransactionExpiration:Ot,TransactionKind:kt,TypeTag:me,ser:I.ser.bind(I),de:I.de.bind(I),getTypeInterface:I.getTypeInterface.bind(I),hasType:I.hasType.bind(I),parseTypeName:I.parseTypeName.bind(I),registerAddressType:I.registerAddressType.bind(I),registerAlias:I.registerAlias.bind(I),registerBcsType:I.registerBcsType.bind(I),registerEnumType:I.registerEnumType.bind(I),registerStructType:I.registerStructType.bind(I),registerType:I.registerType.bind(I),types:I.types};I.registerBcsType("utf8string",()=>u.string({name:"utf8string"}));I.registerBcsType("unsafe_u64",()=>dr());I.registerBcsType("enumKind",e=>wt(e));[Y,H,Tt,Ct,xt,lr,$t,Ut,Ge,bt,vt,Et,Bt,hr,St,It,Ee,jt,_t,At,Ot,kt,me].forEach(e=>{I.registerBcsType(e.name,()=>e)});const Hn=U([p({ImmOrOwned:oe}),p({Shared:p({objectId:h(),initialSharedVersion:U([ee(),h()]),mutable:z()})}),p({Receiving:oe})]),Le=p({Pure:E(ee())}),st=p({Object:Hn}),We=U([Le,st]);function Xn(e,t){return{Pure:Array.from(e instanceof Uint8Array?e:pt(e)?e.toBytes():M.ser(t,e,{maxSize:1/0}).toBytes())}}const G={Pure:Xn,ObjectRef({objectId:e,digest:t,version:r}){return{Object:{ImmOrOwned:{digest:t,version:r,objectId:D(e)}}}},SharedObjectRef({objectId:e,mutable:t,initialSharedVersion:r}){return{Object:{Shared:{mutable:t,initialSharedVersion:r,objectId:D(e)}}}},ReceivingRef({objectId:e,digest:t,version:r}){return{Object:{Receiving:{digest:t,version:r,objectId:D(e)}}}}};function Gt(e){return typeof e=="string"?D(e):"ImmOrOwned"in e.Object?D(e.Object.ImmOrOwned.objectId):"Receiving"in e.Object?D(e.Object.Receiving.objectId):D(e.Object.Shared.objectId)}function Zn(e){return typeof e=="object"&&"Object"in e&&"Shared"in e.Object?e.Object.Shared:void 0}function Yn(e){var t;return((t=Zn(e))==null?void 0:t.mutable)??!1}function F(e,t){return Kt(e,t)}const Qn=e=>U([p({None:U([v(!0),v(null)])}),p({Some:e})]),ke=U([p({kind:v("Input"),index:ee(),value:T(rt()),type:T(v("object"))}),p({kind:v("Input"),index:ee(),value:T(rt()),type:v("pure")})]),ei=[ke,p({kind:v("GasCoin")}),p({kind:v("Result"),index:ee()}),p({kind:v("NestedResult"),index:ee(),resultIndex:ee()})],se=U([...ei]),gr=p({kind:v("MoveCall"),target:W("target",h().validator),typeArguments:E(h()),arguments:E(se)}),pr=p({kind:v("TransferObjects"),objects:E(se),address:se}),yr=p({kind:v("SplitCoins"),coin:se,amounts:E(se)}),mr=p({kind:v("MergeCoins"),destination:se,sources:E(se)}),wr=p({kind:v("MakeMoveVec"),type:T(Qn(Q(h(),Xt()))),objects:E(se)}),br=p({kind:v("Publish"),modules:E(E(ee())),dependencies:E(h())}),Sr=p({kind:v("Upgrade"),modules:E(E(ee())),dependencies:E(h()),packageId:h(),ticket:se}),ti=[gr,pr,yr,mr,br,Sr,wr],ri=U([...ti]),de={MoveCall(e){return F({kind:"MoveCall",target:e.target,arguments:e.arguments??[],typeArguments:e.typeArguments??[]},gr)},TransferObjects(e,t){return t.kind==="Input"&&t.type==="pure"&&typeof t.value!="object"&&(t.value=G.Pure(M.Address.serialize(t.value))),F({kind:"TransferObjects",objects:e,address:t},pr)},SplitCoins(e,t){return t.forEach(r=>{r.kind==="Input"&&r.type==="pure"&&typeof r.value!="object"&&(r.value=G.Pure(M.U64.serialize(r.value)))}),F({kind:"SplitCoins",coin:e,amounts:t},yr)},MergeCoins(e,t){return F({kind:"MergeCoins",destination:e,sources:t},mr)},Publish({modules:e,dependencies:t}){return F({kind:"Publish",modules:e.map(r=>typeof r=="string"?Array.from(ce(r)):r),dependencies:t.map(r=>ye(r))},br)},Upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return F({kind:"Upgrade",modules:e.map(i=>typeof i=="string"?Array.from(ce(i)):i),dependencies:t.map(i=>ye(i)),packageId:r,ticket:n},Sr)},MakeMoveVec({type:e,objects:t}){return F({kind:"MakeMoveVec",type:e?{Some:ne.parseFromStr(e)}:{None:null},objects:t},wr)}};function ni(e){function t(r,n){return e(r,n)}return t.u8=r=>e(M.U8.serialize(r)),t.u16=r=>e(M.U16.serialize(r)),t.u32=r=>e(M.U32.serialize(r)),t.u64=r=>e(M.U64.serialize(r)),t.u128=r=>e(M.U128.serialize(r)),t.u256=r=>e(M.U256.serialize(r)),t.bool=r=>e(M.Bool.serialize(r)),t.string=r=>e(M.String.serialize(r)),t.address=r=>e(M.Address.serialize(r)),t.id=t.address,t}function ii(e,t){const r=Array.from(`${e}::`).map(i=>i.charCodeAt(0)),n=new Uint8Array(r.length+t.length);return n.set(r),n.set(t,r.length),B.blake2b(n,{dkLen:32})}const si=T($(U([p({Epoch:ee()}),p({None:U([v(!0),v(null)])})]))),Lt=W("StringEncodedBigint",e=>{if(!["string","number","bigint"].includes(typeof e))return!1;try{return BigInt(e),!0}catch{return!1}}),ai=p({budget:T(Lt),price:T(Lt),payment:T(E(oe)),owner:T(h())}),Be=p({version:v(1),sender:T(h()),expiration:si,gasConfig:ai,inputs:E(ke),transactions:E(ri)});function Wt(e){return D(e).replace("0x","")}class ie{constructor(t){this.version=1,this.sender=t==null?void 0:t.sender,this.expiration=t==null?void 0:t.expiration,this.gasConfig=(t==null?void 0:t.gasConfig)??{},this.inputs=(t==null?void 0:t.inputs)??[],this.transactions=(t==null?void 0:t.transactions)??[]}static fromKindBytes(t){const r=M.TransactionKind.parse(t),n="ProgrammableTransaction"in r?r.ProgrammableTransaction:null;if(!n)throw new Error("Unable to deserialize from bytes.");const i=F({version:1,gasConfig:{},inputs:n.inputs.map((s,o)=>F({kind:"Input",value:s,index:o,type:L(s,Le)?"pure":"object"},ke)),transactions:n.transactions},Be);return ie.restore(i)}static fromBytes(t){var o;const r=M.TransactionData.parse(t),n=r==null?void 0:r.V1,i="ProgrammableTransaction"in n.kind?(o=n==null?void 0:n.kind)==null?void 0:o.ProgrammableTransaction:null;if(!n||!i)throw new Error("Unable to deserialize from bytes.");const s=F({version:1,sender:n.sender,expiration:n.expiration,gasConfig:n.gasData,inputs:i.inputs.map((a,c)=>F({kind:"Input",value:a,index:c,type:L(a,Le)?"pure":"object"},ke)),transactions:i.transactions},Be);return ie.restore(s)}static restore(t){tt(t,Be);const r=new ie;return Object.assign(r,t),r}static getDigestFromBytes(t){const r=ii("TransactionData",t);return xe(r)}build({maxSizeBytes:t=1/0,overrides:r,onlyTransactionKind:n}={}){const i=this.inputs.map(l=>(tt(l.value,We),l.value)),s={ProgrammableTransaction:{inputs:i,transactions:this.transactions}};if(n)return M.TransactionKind.serialize(s,{maxSize:t}).toBytes();const o=(r==null?void 0:r.expiration)??this.expiration,a=(r==null?void 0:r.sender)??this.sender,c={...this.gasConfig,...r==null?void 0:r.gasConfig};if(!a)throw new Error("Missing transaction sender");if(!c.budget)throw new Error("Missing gas budget");if(!c.payment)throw new Error("Missing gas payment");if(!c.price)throw new Error("Missing gas price");const d={sender:Wt(a),expiration:o||{None:!0},gasData:{payment:c.payment,owner:Wt(this.gasConfig.owner??a),price:BigInt(c.price),budget:BigInt(c.budget)},kind:{ProgrammableTransaction:{inputs:i,transactions:this.transactions}}};return M.TransactionData.serialize({V1:d},{maxSize:t}).toBytes()}getDigest(){const t=this.build({onlyTransactionKind:!1});return ie.getDigestFromBytes(t)}snapshot(){return F(this,Be)}}var Mt=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},O=(e,t,r)=>(Mt(e,t,"read from private field"),r?r.call(e):t.get(e)),re=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},$e=(e,t,r,n)=>(Mt(e,t,"write to private field"),t.set(e,r),r),R=(e,t,r)=>(Mt(e,t,"access private method"),r),j,Te,Pe,ve,Ne,ue,fe,Rt,Tr,Pt,vr,Nt,jr,Dt,Er,De,at;const oi={maxPureArgumentSize:16*1024,maxTxGas:5e10,maxGasObjects:256,maxTxSizeBytes:128*1024};function ci(e){const t={kind:"Result",index:e},r=[],n=i=>r[i]??(r[i]={kind:"NestedResult",index:e,resultIndex:i});return new Proxy(t,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,s){if(s in i)return Reflect.get(i,s);if(s===Symbol.iterator)return function*(){let a=0;for(;;)yield n(a),a++};if(typeof s=="symbol")return;const o=parseInt(s,10);if(!(Number.isNaN(o)||o<0))return n(o)}})}function ui(e){const t=ft(e);return t?t.Struct.address==="0x2"&&t.Struct.module==="transfer"&&t.Struct.name==="Receiving":!1}function Oe(e){if(!e.client)throw new Error("No provider passed to Transaction#build, but transaction data was not sufficient to build offline.");return e.client}const di=Symbol.for("@mysten/transaction"),et={maxTxGas:"max_tx_gas",maxGasObjects:"max_gas_payment_objects",maxTxSizeBytes:"max_tx_size_bytes",maxPureArgumentSize:"max_pure_argument_size"},li=1000n,fi=50,hi=(e,t)=>Array.from({length:Math.ceil(e.length/t)},(r,n)=>e.slice(n*t,n*t+t)),ot=class{constructor(e){re(this,Te),re(this,ve),re(this,ue),re(this,Rt),re(this,Pt),re(this,Nt),re(this,Dt),re(this,De),re(this,j,void 0),$e(this,j,new ie(e?e.blockData:void 0))}static fromKind(e){const t=new ot;return $e(t,j,ie.fromKindBytes(typeof e=="string"?ce(e):e)),t}static from(e){const t=new ot;return typeof e!="string"||!e.startsWith("{")?$e(t,j,ie.fromBytes(typeof e=="string"?ce(e):e)):$e(t,j,ie.restore(JSON.parse(e))),t}setSender(e){O(this,j).sender=e}setSenderIfNotSet(e){O(this,j).sender||(O(this,j).sender=e)}setExpiration(e){O(this,j).expiration=e}setGasPrice(e){O(this,j).gasConfig.price=String(e)}setGasBudget(e){O(this,j).gasConfig.budget=String(e)}setGasOwner(e){O(this,j).gasConfig.owner=e}setGasPayment(e){O(this,j).gasConfig.payment=e.map(t=>Jt(t,oe))}get blockData(){return O(this,j).snapshot()}get[di](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:ni((e,t)=>pt(e)?R(this,Te,Pe).call(this,"pure",{Pure:Array.from(e.toBytes())}):R(this,Te,Pe).call(this,"pure",e instanceof Uint8Array?G.Pure(e):t?G.Pure(e,t):e))}),this.pure}get gas(){return{kind:"GasCoin"}}object(e){if(typeof e=="object"&&"kind"in e)return e;const t=Gt(e),r=O(this,j).inputs.find(n=>n.type==="object"&&t===Gt(n.value));return r&&L(r.value,st)&&"Shared"in r.value.Object&&L(e,st)&&"Shared"in e.Object&&(r.value.Object.Shared.mutable=r.value.Object.Shared.mutable||e.Object.Shared.mutable),r??R(this,Te,Pe).call(this,"object",typeof e=="string"?D(e):e)}objectRef(...e){return this.object(G.ObjectRef(...e))}receivingRef(...e){return this.object(G.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(G.SharedObjectRef(...e))}add(e){const t=O(this,j).transactions.push(e);return ci(t-1)}splitCoins(e,t){return this.add(de.SplitCoins(typeof e=="string"?this.object(e):e,t.map(r=>typeof r=="number"||typeof r=="bigint"||typeof r=="string"?this.pure.u64(r):R(this,ve,Ne).call(this,r))))}mergeCoins(e,t){return this.add(de.MergeCoins(typeof e=="string"?this.object(e):e,t.map(r=>typeof r=="string"?this.object(r):r)))}publish({modules:e,dependencies:t}){return this.add(de.Publish({modules:e,dependencies:t}))}upgrade({modules:e,dependencies:t,packageId:r,ticket:n}){return this.add(de.Upgrade({modules:e,dependencies:t,packageId:r,ticket:typeof n=="string"?this.object(n):n}))}moveCall({arguments:e,typeArguments:t,target:r}){return this.add(de.MoveCall({arguments:e==null?void 0:e.map(n=>R(this,ve,Ne).call(this,n)),typeArguments:t,target:r}))}transferObjects(e,t){return this.add(de.TransferObjects(e.map(r=>typeof r=="string"?this.object(r):r),typeof t=="string"?this.pure.address(t):R(this,ve,Ne).call(this,t)))}makeMoveVec({type:e,objects:t}){return this.add(de.MakeMoveVec({type:e,objects:t.map(r=>typeof r=="string"?this.object(r):r)}))}serialize(){return JSON.stringify(O(this,j).snapshot())}async sign(e){const{signer:t,...r}=e,n=await this.build(r);return t.signTransactionBlock(n)}async build(e={}){return await R(this,De,at).call(this,e),O(this,j).build({maxSizeBytes:R(this,ue,fe).call(this,"maxTxSizeBytes",e),onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await R(this,De,at).call(this,e),O(this,j).getDigest()}};let Ue=ot;j=new WeakMap;Te=new WeakSet;Pe=function(e,t){const r=O(this,j).inputs.length,n=F({kind:"Input",value:typeof t=="bigint"?String(t):t,index:r,type:e},ke);return O(this,j).inputs.push(n),n};ve=new WeakSet;Ne=function(e){return pt(e)?this.pure(e):e};ue=new WeakSet;fe=function(e,{protocolConfig:t,limits:r}){if(r&&typeof r[e]=="number")return r[e];if(!t)return oi[e];const n=t==null?void 0:t.attributes[et[e]];if(!n)throw new Error(`Missing expected protocol config: "${et[e]}"`);const i="u64"in n?n.u64:"u32"in n?n.u32:n.f64;if(!i)throw new Error(`Unexpected protocol config value found for: "${et[e]}"`);return Number(i)};Rt=new WeakSet;Tr=function(e){const t=R(this,ue,fe).call(this,"maxPureArgumentSize",e);O(this,j).inputs.forEach((r,n)=>{if(L(r.value,Le)&&r.value.Pure.length>t)throw new Error(`Input at index ${n} is too large, max pure input size is ${t} bytes, got ${r.value.Pure.length} bytes`)})};Pt=new WeakSet;vr=async function(e){if(O(this,j).gasConfig.payment){const i=R(this,ue,fe).call(this,"maxGasObjects",e);if(O(this,j).gasConfig.payment.length>i)throw new Error(`Payment objects exceed maximum amount: ${i}`)}if(e.onlyTransactionKind||O(this,j).gasConfig.payment)return;const t=O(this,j).gasConfig.owner??O(this,j).sender,n=(await Oe(e).getCoins({owner:t,coinType:Re})).data.filter(i=>!O(this,j).inputs.find(o=>L(o.value,We)&&"Object"in o.value&&"ImmOrOwned"in o.value.Object?i.coinObjectId===o.value.Object.ImmOrOwned.objectId:!1)).slice(0,R(this,ue,fe).call(this,"maxGasObjects",e)-1).map(i=>({objectId:i.coinObjectId,digest:i.digest,version:i.version}));if(!n.length)throw new Error("No valid gas coins found for the transaction.");this.setGasPayment(n)};Nt=new WeakSet;jr=async function(e){e.onlyTransactionKind||O(this,j).gasConfig.price||this.setGasPrice(await Oe(e).getReferenceGasPrice())};Dt=new WeakSet;Er=async function(e){const{inputs:t,transactions:r}=O(this,j),n=[],i=[];if(t.forEach(s=>{if(s.type==="object"&&typeof s.value=="string"){i.push({id:D(s.value),input:s});return}}),r.forEach(s=>{if(s.kind==="MoveCall"&&s.arguments.some(a=>a.kind==="Input"&&!L(t[a.index].value,We))&&n.push(s),s.kind==="SplitCoins"&&s.amounts.forEach(o=>{if(o.kind==="Input"){const a=t[o.index];typeof a.value!="object"&&(a.value=G.Pure(M.U64.serialize(a.value)))}}),s.kind==="TransferObjects"&&s.address.kind==="Input"){const o=t[s.address.index];typeof o.value!="object"&&(o.value=G.Pure(M.Address.serialize(o.value)))}}),n.length&&await Promise.all(n.map(async s=>{const[o,a,c]=s.target.split("::"),d=await Oe(e).getNormalizedMoveFunction({package:ye(o),module:a,function:c}),g=d.parameters.length>0&&Nn(d.parameters.at(-1))?d.parameters.slice(0,d.parameters.length-1):d.parameters;if(g.length!==s.arguments.length)throw new Error("Incorrect number of arguments.");g.forEach((m,y)=>{const w=s.arguments[y];if(w.kind!=="Input")return;const b=t[w.index];if(L(b.value,We))return;const f=b.value,x=it(m,f);if(x){b.value=G.Pure(f,x);return}if(ft(m)!=null||typeof m=="object"&&"TypeParameter"in m){if(typeof f!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(f,null,2)}`);i.push({id:f,input:b,normalizedType:m});return}throw new Error(`Unknown call arg type ${JSON.stringify(m,null,2)} for value ${JSON.stringify(f,null,2)}`)})})),i.length){const s=[...new Set(i.map(({id:l})=>l))],o=hi(s,fi),a=(await Promise.all(o.map(l=>Oe(e).multiGetObjects({ids:l,options:{showOwner:!0}})))).flat();let c=new Map(s.map((l,g)=>[l,a[g]]));const d=Array.from(c).filter(([l,g])=>g.error).map(([l,g])=>l);if(d.length)throw new Error(`The following input objects are invalid: ${d.join(", ")}`);i.forEach(({id:l,input:g,normalizedType:m})=>{var f;const y=c.get(l),w=(f=y.data)==null?void 0:f.owner,b=w&&typeof w=="object"&&"Shared"in w?w.Shared.initial_shared_version:void 0;if(b){const x=m!=null&&nt(m)==null&&tr(m)==null,C=Yn(g.value)||x||m!=null&&nt(m)!=null;g.value=G.SharedObjectRef({objectId:l,initialSharedVersion:b,mutable:C})}else m&&ui(m)?g.value=G.ReceivingRef(Ft(y)):g.value=G.ObjectRef(Ft(y))})}};De=new WeakSet;at=async function(e){if(!e.onlyTransactionKind&&!O(this,j).sender)throw new Error("Missing transaction sender");if(!e.protocolConfig&&!e.limits&&e.client&&(e.protocolConfig=await e.client.getProtocolConfig()),await Promise.all([R(this,Nt,jr).call(this,e),R(this,Dt,Er).call(this,e)]),!e.onlyTransactionKind&&(await R(this,Pt,vr).call(this,e),!O(this,j).gasConfig.budget)){const t=await Oe(e).dryRunTransactionBlock({transactionBlock:O(this,j).build({maxSizeBytes:R(this,ue,fe).call(this,"maxTxSizeBytes",e),overrides:{gasConfig:{budget:String(R(this,ue,fe).call(this,"maxTxGas",e)),payment:[]}}})});if(t.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${t.effects.status.error}`,{cause:t});const r=li*BigInt(this.blockData.gasConfig.price||1n),n=BigInt(t.effects.gasUsed.computationCost)+r,i=n+BigInt(t.effects.gasUsed.storageCost)-BigInt(t.effects.gasUsed.storageRebate);this.setGasBudget(i>n?i:n)}R(this,Rt,Tr).call(this,e)};const kr=async(e,t,r)=>{var o,a,c;if(!S.isValidSuiType(r))throw new Error(`Invalid Sui type: ${r}`);const n=await S.getObjectFields(e,t);if(!n)throw new Error(`Unable to fetch object fields from token bridge state. Object ID: ${t}`);const i=(a=(o=n.token_registry.fields)==null?void 0:o.id)==null?void 0:a.id;if(!i)throw new Error("Unable to fetch token registry object ID");const s=S.getPackageIdFromType((c=n.token_registry)==null?void 0:c.type);if(!s)throw new Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:i,name:{type:`${s}::token_registry::Key<${r}>`,value:{dummy_field:!1}}})},ct=async(e,t,r,n)=>{var l,g,m,y;const i=await S.getObjectFields(e,t);if(!i)throw new Error("Unable to fetch object fields from token bridge state");const s=(g=(l=i.token_registry)==null?void 0:l.fields)==null?void 0:g.coin_types,o=(y=(m=s==null?void 0:s.fields)==null?void 0:m.id)==null?void 0:y.id;if(!o)throw new Error("Unable to fetch coin types");const a=S.getTableKeyType(s==null?void 0:s.type);if(!a)throw new Error("Unable to get key type");const c=await e.getDynamicFieldObject({parentId:o,name:{type:a,value:{addr:[...r],chain:n}}});if(c.error){if(c.error.code==="dynamicFieldNotFound")return null;throw new Error(`Unexpected getDynamicFieldObject response ${c.error}`)}const d=S.getFieldsFromObjectResponse(c);if(!d)return null;if(!S.isMoveStructObject(d))throw new Error("What?");return"value"in d?S.trimSuiType(d.value):null};class Je{constructor(t,r,n,i){V(this,"network");V(this,"chain");V(this,"provider");V(this,"contracts");V(this,"coreBridgeObjectId");V(this,"tokenBridgeObjectId");V(this,"chainId");this.network=t,this.chain=r,this.provider=n,this.contracts=i,this.chainId=B.networkChainToNativeChainId.get(t,r);const s=this.contracts.tokenBridge;if(!s)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);const o=this.contracts.coreBridge;if(!o)throw new Error(`Wormhole Token Bridge contract for domain ${r} not found`);this.tokenBridgeObjectId=s,this.coreBridgeObjectId=o}static async fromRpc(t,r){const[n,i]=await S.SuiPlatform.chainFromRpc(t),s=r[i];if(s.network!==n)throw new Error(`Network mismatch: ${s.network} != ${n}`);return new Je(n,i,t,s.contracts)}async isWrappedAsset(t){try{return await this.getOriginalAsset(t),!0}catch{return!1}}async getOriginalAsset(t){let r=t.getCoinType();if(!S.isValidSuiType(r))throw new Error(`Invalid Sui type: ${r}`);const n=await kr(this.provider,this.tokenBridgeObjectId,r),i=S.getFieldsFromObjectResponse(n);if(!i)throw B.ErrNotWrapped(r);if(!S.isMoveStructObject(i))throw new Error("Expected fields to be a MoveStruct");if(!("value"in i))throw new Error("Expected a `value` key in fields of MoveStruct");const s=i.value;if(!S.isMoveStructStruct(s))throw new Error("Expected fields to be a MoveStruct");const o=S.trimSuiType(s.type);if(r=S.trimSuiType(r),o.includes(`wrapped_asset::WrappedAsset<${r}>`)){const a=s.fields.info;if(!S.isMoveStructStruct(a))throw new Error("Expected fields to be a MoveStruct");const c=a.fields.token_address;if(!S.isMoveStructStruct(c))throw new Error("Expected fields to be a MoveStruct");if(!S.isMoveStructObject(c.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in c.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const d=c.fields.value;if(!S.isMoveStructStruct(d))throw new Error("Expected fields to be a MoveStruct");return{chain:B.toChain(Number(a.fields.token_chain)),address:new B.UniversalAddress(d.fields.data)}}throw B.ErrNotWrapped(r)}async hasWrappedAsset(t){try{return await this.getWrappedAsset(t),!0}catch{}return!1}async getWrappedAsset(t){if(B.isNative(t.address))throw new Error("Token Address required, 'native' literal not supported");const r=await ct(this.provider,this.tokenBridgeObjectId,t.address.toUniversalAddress().toUint8Array(),B.toChainId(t.chain));if(!r)throw B.ErrNotWrapped(B.canonicalAddress(t));return B.toNative(this.chain,r)}async isTransferCompleted(t){var a,c,d,l,g,m,y,w;const r=await S.getObjectFields(this.provider,this.tokenBridgeObjectId);if(!r)throw new Error("Unable to fetch object fields from token bridge state");const n=(c=(a=r.consumed_vaas)==null?void 0:a.fields)==null?void 0:c.hashes,i=S.getTableKeyType((l=(d=n==null?void 0:n.fields)==null?void 0:d.items)==null?void 0:l.type);if(!i)throw new Error("Unable to get key type");const s=(w=(y=(m=(g=n==null?void 0:n.fields)==null?void 0:g.items)==null?void 0:m.fields)==null?void 0:y.id)==null?void 0:w.id;if(!s)throw new Error("Unable to fetch consumed VAAs table");const o=await this.provider.getDynamicFieldObject({parentId:s,name:{type:i,value:{data:[...B.keccak_256(t.hash)]}}});if(!o.error)return!0;if(o.error.code==="dynamicFieldNotFound")return!1;throw new Error(`Unexpected getDynamicFieldObject response ${o.error}`)}async*createAttestation(t){const r=0n,n=0n,i=t.toString(),s=await this.provider.getCoinMetadata({coinType:i});if(s===null||s.id===null)throw new Error(`Coin metadata ID for type ${i} not found`);const[o,a]=await this.getPackageIds(),c=new Ue,[d]=c.splitCoins(c.gas,[c.pure(r)]),[l]=c.moveCall({target:`${a}::attest_token::attest_token`,arguments:[c.object(this.tokenBridgeObjectId),c.object(s.id),c.pure(n)],typeArguments:[i]});c.moveCall({target:`${o}::publish_message::publish_message`,arguments:[c.object(this.coreBridgeObjectId),d,l,c.object(we)]}),yield this.createUnsignedTx(c,"Sui.TokenBridge.CreateAttestation")}async*submitAttestation(t,r){const[n,i]=await this.getPackageIds(),s=r.toString(),o=Math.min(t.payload.decimals,8),a=await this.getCoinBuildOutput(n,i,o),c=await S.publishPackage(a,s);yield this.createUnsignedTx(c,"Sui.TokenBridge.PrepareCreateWrapped");let d="",l="",g="",m="",y="",w=!1;for(;!w;){await new Promise(A=>setTimeout(A,500));const P=await this.provider.queryTransactionBlocks({filter:{FromAddress:s},options:{showObjectChanges:!0},limit:3});for(const A of P.data)if("objectChanges"in A){for(const k of A.objectChanges)S.isSuiPublishEvent(k)&&k.packageId!==void 0?d=k.packageId:S.isSuiCreateEvent(k)&&k.objectType.includes("WrappedAssetSetup")?(l=k.objectId,y=k.objectType.split(", ")[1].replace(">","")):S.isSuiCreateEvent(k)&&k.objectType.includes("UpgradeCap")?g=k.objectId:S.isSuiCreateEvent(k)&&k.objectType.includes("CoinMetadata")&&(m=k.objectId);if(d!==""&&l!==""&&g!==""&&m!==""){w=!0;break}else d="",l="",g="",m=""}}const b=S.getCoinTypeFromPackageId(d),f=new Ue,[x]=f.moveCall({target:`${n}::vaa::parse_and_verify`,arguments:[f.object(this.coreBridgeObjectId),f.pure(S.uint8ArrayToBCS(B.serialize(t))),f.object(we)]}),[C]=f.moveCall({target:`${i}::vaa::verify_only_once`,arguments:[f.object(this.tokenBridgeObjectId),x]});f.moveCall({target:`${i}::create_wrapped::complete_registration`,arguments:[f.object(this.tokenBridgeObjectId),f.object(m),f.object(l),f.object(g),C],typeArguments:[b,y]}),yield this.createUnsignedTx(f,"Sui.TokenBridge.SubmitAttestation")}async*transfer(t,r,n,i,s){const o=0n,a=0n,d=t.toString(),l=(B.isNative(n)?Re:n).toString(),g=(await this.provider.getCoins({owner:d,coinType:l})).data,[m,...y]=g.filter(A=>S.isSameType(A.coinType,l));if(m===void 0)throw new Error(`Coins array doesn't contain any coins of type ${l}`);const[w,b]=await this.getPackageIds(),f=new Ue,[x]=(()=>{if(l===Re)return f.splitCoins(f.gas,[f.pure(i)]);{const A=f.object(m.coinObjectId);return y.length&&f.mergeCoins(A,y.map(k=>f.object(k.coinObjectId))),f.splitCoins(A,[f.pure(i)])}})(),[C]=f.splitCoins(f.gas,[f.pure(o)]),[P]=f.moveCall({target:`${b}::state::verified_asset`,arguments:[f.object(this.tokenBridgeObjectId)],typeArguments:[l]});if(s){if(!d)throw new Error("senderAddress is required for transfer with payload");let A=!1;const k=await(async()=>{const zt=await S.getOldestEmitterCapObjectId(this.provider,w,d);if(zt!==null)return f.object(zt);{const[Or]=f.moveCall({target:`${w}::emitter::new`,arguments:[f.object(this.coreBridgeObjectId)]});return A=!0,Or}})(),[N,q]=f.moveCall({target:`${b}::transfer_tokens_with_payload::prepare_transfer`,arguments:[k,P,x,f.pure(B.toChainId(r.chain)),f.pure(r.address.toUint8Array()),f.pure([...s]),f.pure(0)],typeArguments:[l]});f.moveCall({target:`${b}::coin_utils::return_nonzero`,arguments:[q],typeArguments:[l]});const[he]=f.moveCall({target:`${b}::transfer_tokens_with_payload::transfer_tokens_with_payload`,arguments:[f.object(this.tokenBridgeObjectId),N],typeArguments:[l]});f.moveCall({target:`${w}::publish_message::publish_message`,arguments:[f.object(this.coreBridgeObjectId),C,he,f.object(we)]}),A&&f.transferObjects([k],f.pure(d)),yield this.createUnsignedTx(f,"Sui.TokenBridge.TransferWithPayload")}else{const[A,k]=f.moveCall({target:`${b}::transfer_tokens::prepare_transfer`,arguments:[P,x,f.pure(B.toChainId(r.chain)),f.pure(S.uint8ArrayToBCS(r.address.toUint8Array())),f.pure(a),f.pure(0)],typeArguments:[l]});f.moveCall({target:`${b}::coin_utils::return_nonzero`,arguments:[k],typeArguments:[l]});const[N]=f.moveCall({target:`${b}::transfer_tokens::transfer_tokens`,arguments:[f.object(this.tokenBridgeObjectId),A],typeArguments:[l]});f.moveCall({target:`${w}::publish_message::publish_message`,arguments:[f.object(this.coreBridgeObjectId),C,N,f.object(we)]}),yield this.createUnsignedTx(f,"Sui.TokenBridge.Transfer")}}async*redeem(t,r,n=!0){const i=await ct(this.provider,this.tokenBridgeObjectId,r.payload.token.address.toUint8Array(),B.toChainId(r.payload.token.chain));if(!i)throw new Error("Unable to fetch token coinType");const[s,o]=await this.getPackageIds(),a=new Ue,[c]=a.moveCall({target:`${s}::vaa::parse_and_verify`,arguments:[a.object(this.coreBridgeObjectId),a.pure(S.uint8ArrayToBCS(B.serialize(r))),a.object(we)]}),[d]=a.moveCall({target:`${o}::vaa::verify_only_once`,arguments:[a.object(this.tokenBridgeObjectId),c]}),[l]=a.moveCall({target:`${o}::complete_transfer::authorize_transfer`,arguments:[a.object(this.tokenBridgeObjectId),d],typeArguments:[i]}),[g]=a.moveCall({target:`${o}::complete_transfer::redeem_relayer_payout`,arguments:[l],typeArguments:[i]});a.moveCall({target:`${o}::coin_utils::return_nonzero`,arguments:[g],typeArguments:[i]}),yield this.createUnsignedTx(a,"Sui.TokenBridge.Redeem")}async getWrappedNative(){const t=await this.provider.getCoinMetadata({coinType:Re});if(!t)throw new Error("Coin metadata not found");return B.toNative(this.chain,t.id)}async getPackageIds(){return Promise.all([S.getPackageId(this.provider,this.coreBridgeObjectId),S.getPackageId(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(t,r,n){var a;if(n>8)throw new Error("Decimals is capped at 8");const i=(a=await S.getOriginalPackageId(this.provider,this.tokenBridgeObjectId))==null?void 0:a.replace("0x","");if(!i)throw new Error(`Original token bridge package ID not found for object ID ${this.tokenBridgeObjectId}`);const s="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+i+"00020106010000000001090b0031"+n.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[B.b64.encode(B.hex.decode(s))],dependencies:["0x1","0x2",r,t].map(c=>ye(c))}}createUnsignedTx(t,r,n=!1){return new _r(t,this.network,this.chain,r,n)}}Ar.registerProtocol(S._platform,"TokenBridge",Je);exports.SuiTokenBridge=Je;exports.getTokenCoinType=ct;exports.getTokenFromTokenRegistry=kr;

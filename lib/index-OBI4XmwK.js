"use strict";var y=Object.defineProperty;var g=(d,e,t)=>e in d?y(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t;var i=(d,e,t)=>(g(d,typeof e!="symbol"?e+"":e,t),t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const r=require("./index-BMvV5qga.js"),o=require("./aptos-DzHwqo0G.js"),f=require("./chain-DBb0uF1j.js");class k{constructor(e,t,s,n,a=!1){i(this,"transaction");i(this,"network");i(this,"chain");i(this,"description");i(this,"parallelizable");this.transaction=e,this.network=t,this.chain=s,this.description=n,this.parallelizable=a}}const w=[{name:"tokenBridgeAddress",...r.universalAddressItem},{name:"chain",...r.chainItem()},{name:"domainSeparator",binary:"bytes",custom:r.bytes.encode(o.APTOS_SEPARATOR),omit:!0},{name:"tokenId",...r.universalAddressItem},{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}],m=d=>r.serializeLayout(w,d);class c{constructor(e,t,s,n){i(this,"network");i(this,"chain");i(this,"connection");i(this,"contracts");i(this,"chainId");i(this,"tokenBridgeAddress");this.network=e,this.chain=t,this.connection=s,this.contracts=n,this.chainId=r.toChainId(t);const a=n.tokenBridge;if(!a)throw new Error(`TokenBridge contract Address for chain ${t} not found`);this.tokenBridgeAddress=a}static async fromRpc(e,t){const[s,n]=await o.AptosPlatform.chainFromRpc(e),a=t[n];if(a.network!==s)throw new Error("Network mismatch "+a.network+" !== "+s);return new c(s,n,e,a.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{return!1}}async getOriginalAsset(e){const t=e.toString().split(o.APTOS_SEPARATOR);let s;if(s=(await this.connection.getAccountResource(t[0],`${this.tokenBridgeAddress}::state::OriginInfo`)).data,!s)throw r.ErrNotWrapped;const n=r.toChain(parseInt(s.token_chain.number)),a=new r.UniversalAddress(s.token_address.external_address);return{chain:n,address:a}}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource(o.coalesceModuleAddress(t),`${this.tokenBridgeAddress}::state::OriginInfo`),r.toNative(this.chain,t)}async isTransferCompleted(e){const s=(await this.connection.getAccountResource(this.tokenBridgeAddress,`${this.tokenBridgeAddress}::state::State`)).data.consumed_vaas.elems.handle;try{return await this.connection.getTableItem(s,{key_type:"vector<u8>",value_type:"u8",key:`0x${r.dist.Buffer.from(r.keccak_256(e.hash)).toString("hex")}`}),!0}catch{return!1}}async getWrappedNative(){return r.toNative(this.chain,o.APTOS_COIN)}async*createAttestation(e,t){const s={chain:this.chain,address:new o.AptosAddress(e)},n=await this.getAssetFullyQualifiedType(s);if(!n)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::attest_token::attest_token_entry`,type_arguments:[n],arguments:[]},"Aptos.AttestToken")}async*submitAttestation(e,t){yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin_type`,type_arguments:[],arguments:[r.serialize(e)]},"Aptos.CreateWrappedCoinType");const s=await this.getAssetFullyQualifiedType(e.payload.token);if(!s)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::wrapped::create_wrapped_coin`,type_arguments:[s],arguments:[r.serialize(e)]},"Aptos.CreateWrappedCoin")}async*transfer(e,t,s,n,a){const A=0n,h=0n,l=r.isNative(s)?o.APTOS_COIN:s.toString(),u=t.address.toUniversalAddress().toUint8Array(),p=r.toChainId(t.chain);a?yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_with_payload_entry`,type_arguments:[l],arguments:[n,p,u,h,a]},"Aptos.TransferTokensWithPayload"):yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::transfer_tokens::transfer_tokens_entry`,type_arguments:[l],arguments:[n,p,u,A,h]},"Aptos.TransferTokens")}async*redeem(e,t,s=!0){const n=t.payload.token.chain===this.chain?await this.getTypeFromExternalAddress(t.payload.token.address.toString()):await this.getAssetFullyQualifiedType(t.payload.token);if(!n)throw new Error("Invalid asset address.");yield this.createUnsignedTx({function:`${this.tokenBridgeAddress}::complete_transfer::submit_vaa_and_register_entry`,type_arguments:[n],arguments:[r.serialize(t)]},"Aptos.CompleteTransfer")}async getAssetFullyQualifiedType(e){return e.chain===this.chain?o.isValidAptosType(e.address.toString())?e.address.toString():null:`${c.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e)}::coin::T`}async getTypeFromExternalAddress(e){try{const t=(await this.connection.getAccountResource(this.tokenBridgeAddress,`${this.tokenBridgeAddress}::state::State`)).data,{handle:s}=t.native_infos,n=await this.connection.getTableItem(s,{key_type:`${this.tokenBridgeAddress}::token_hash::TokenHash`,value_type:"0x1::type_info::TypeInfo",key:{hash:e}});return n?[n.account_address,r.hex.decode(n.module_name),r.hex.decode(n.struct_name)].join(o.APTOS_SEPARATOR):null}catch{return null}}static getForeignAssetAddress(e,t,s){if(r.isNative(s.address))throw new Error("Invalid token address");const n=m({chain:s.chain,tokenBridgeAddress:new o.AptosAddress(t).toUniversalAddress(),tokenId:s.address.toUniversalAddress()});return r.hex.encode(r.sha3_256(n),!0)}createUnsignedTx(e,t,s=!1){return new k(e,this.network,this.chain,t,s)}}f.registerProtocol("Aptos","TokenBridge",c);exports.AptosTokenBridge=c;

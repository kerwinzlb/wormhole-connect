"use strict";var y=Object.defineProperty;var S=(s,t,n)=>t in s?y(s,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[t]=n;var g=(s,t,n)=>(S(s,typeof t!="symbol"?t+"":t,n),n);const o=require("./index-BMvV5qga.js"),w=require("./chain-DBb0uF1j.js"),m="Algorand";function I(s){if(s<BigInt(Number.MIN_SAFE_INTEGER)||s>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Integer is unsafe");return Number(s)}const N="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ",u=class u{constructor(t){g(this,"type","Native");g(this,"address");if(u.instanceof(t))this.address=t.address;else if(o.UniversalAddress.instanceof(t))this.address=t.toUint8Array();else if(t instanceof Uint8Array&&t.byteLength===u.byteSize)this.address=t;else if(typeof t=="string"&&o.isValidAddress(t))this.address=o.decodeAddress(t).publicKey;else if(typeof t=="string"&&!isNaN(parseInt(t)))this.address=o.bytes.zpad(o.bignum.toBytes(BigInt(t),8),u.byteSize);else if(typeof t=="bigint")this.address=o.bytes.zpad(o.bignum.toBytes(t,8),u.byteSize);else if(t instanceof Uint8Array&&t.byteLength===8)this.address=o.bytes.zpad(t,u.byteSize);else throw new Error(`Invalid Algorand address or ASA ID: ${t}`)}unwrap(){return this.toString()}toString(){return o.encodeAddress(this.address)}toNative(){return this}toUint8Array(){return this.address}toUniversalAddress(){return new o.UniversalAddress(this.toUint8Array())}toBigInt(){return o.bignum.decode(this.toUint8Array().slice(24,32))}toInt(){return I(this.toBigInt())}equals(t){return u.instanceof(t)?t.address===this.address:this.toUniversalAddress().equals(t)}static instanceof(t){return t.constructor.platform===m}};g(u,"byteSize",32),g(u,"platform",m);let h=u;o.registerNative(m,h);class b extends w.ChainContext{}const A=class A extends w.PlatformContext{constructor(t,n){super(t,n??o.networkPlatformConfigs(t,A._platform))}getRpc(t){if(t in this.config)return new o.algosdk.Algodv2("",this.config[t].rpc);throw new Error("No configuration available for chain: "+t)}getChain(t){if(t in this.config)return new b(t,this);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(t,n){if(!A.isSupportedChain(n))throw new Error(`invalid chain for Algorand: ${n}`);return o.Wormhole.chainAddress(n,N)}static isNativeTokenId(t,n,e){return!A.isSupportedChain(n)||e.chain!==n?!1:this.nativeTokenId(t,n)==e}static isSupportedChain(t){return o.chainToPlatform(t)===A._platform}static async getDecimals(t,n,e){const i=o.isNative(e)?0:new h(e).toInt();if(i===0)return o.nativeDecimals(A._platform);const d=await n.getAssetByID(i).do(),a=o.algosdk.modelsv2.Asset.from_obj_for_encoding(d);if(!a.params||!a.params.decimals)throw new Error("Could not fetch token details");return Number(a.params.decimals)}static async getBalance(t,n,e,i){const d=o.isNative(i)?0:new h(i).toInt();if(d===0){const c=await n.accountInformation(e).do(),f=o.algosdk.modelsv2.Account.from_obj_for_encoding(c);return BigInt(f.amount)}const a=await n.accountAssetInformation(e,d).do(),r=o.algosdk.modelsv2.AssetHolding.from_obj_for_encoding(a);return BigInt(r.amount)}static async getBalances(t,n,e,i){let d;if(i.includes("native")){const r=await n.accountInformation(e).do(),c=o.algosdk.modelsv2.Account.from_obj_for_encoding(r);d=BigInt(c.amount)}return i.map(async r=>{if(o.isNative(r))return{native:d};const c=new h(r).toInt(),f=await n.accountAssetInformation(e,c).do(),l=o.algosdk.modelsv2.AssetHolding.from_obj_for_encoding(f);return BigInt(l.amount)}).reduce((r,c)=>Object.assign(r,c),{})}static async sendWait(t,n,e){const a=e.map((l,v)=>o.algosdk.decodeSignedTransaction(l)).map((l,v)=>l.txn.txID()),{txId:r}=await n.sendRawTransaction(e).do();if(!r)throw new Error("Transaction(s) failed to send");const c=await o.algosdk.waitForConfirmation(n,r,4);if(!o.algosdk.modelsv2.PendingTransactionResponse.from_obj_for_encoding(c).confirmedRound)throw new Error("Transaction(s) could not be confirmed in 4 rounds");return a}static async getLatestBlock(t){const n=await t.status().do(),e=o.algosdk.modelsv2.NodeStatusResponse.from_obj_for_encoding(n);if(!e.lastRound)throw new Error("Error getting status from node");return Number(e.lastRound)}static async getLatestFinalizedBlock(t){const n=await t.status().do(),e=o.algosdk.modelsv2.NodeStatusResponse.from_obj_for_encoding(n);if(!e.lastRound)throw new Error("Error getting status from node");return Number(e.lastRound)}static chainFromChainId(t){const n=o.platformNativeChainIdToNetworkChain(A._platform,t);if(n===void 0)throw new Error(`Unknown native chain id ${t}`);const[e,i]=n;return[e,i]}static async chainFromRpc(t){const n=await t.versionsCheck().do(),e=o.algosdk.modelsv2.Version.from_obj_for_encoding(n);return this.chainFromChainId(e.genesisId)}};g(A,"_platform",m);let p=A;async function x(s,t){const[n,e]=await p.chainFromRpc(s);return new C(e,s,t)}class C{constructor(t,n,e,i=!1){g(this,"_chain");g(this,"_debug");g(this,"_account");this._chain=t,this._debug=i,this._account=o.mnemonicToSecretKey(e)}chain(){return this._chain}address(){return this._account.addr}async sign(t){const n=[],e=t.map((a,r)=>a.transaction.tx),i=o.assignGroupID(e),d=t.map((a,r)=>(a.transaction.tx=i[r],a));for(const a of d){const{description:r,transaction:c}=a,{tx:f,signer:l}=c;this._debug&&(console.log(f._getDictForDisplay()),console.log(f.txID())),l?(this._debug&&console.log(`Signing: ${r} with signer ${l.address} for address ${this.address()}`),n.push(await l.signTxn(f))):(this._debug&&console.log(`Signing: ${r} without signer for address ${this.address()}`),n.push(f.signTxn(this._account.sk)))}return n}}const R={Address:h,Platform:p,getSigner:x,protocols:{WormholeCore:()=>Promise.resolve().then(()=>require("./index-DyKKa0fa.js")).then(s=>s.index),TokenBridge:()=>Promise.resolve().then(()=>require("./index-8WL-HRt9.js"))},getChain:(s,t,n)=>new b(t,new p(s,o.applyChainsConfigConfigOverrides(s,m,{[t]:n})))},k=Object.freeze(Object.defineProperty({__proto__:null,default:R},Symbol.toStringTag,{value:"Module"}));exports.AlgorandAddress=h;exports.AlgorandPlatform=p;exports._platform=m;exports.algorand=k;exports.safeBigIntToNumber=I;

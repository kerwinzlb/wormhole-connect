"use strict";var _=Object.defineProperty;var v=(h,e,t)=>e in h?_(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var c=(h,e,t)=>(v(h,typeof e!="symbol"?e+"":e,t),t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});require("./index-CxnM5k14.js");const i=require("./cosmwasm-Cs-vbaNE.js"),o=require("./unsignedTransaction-BVYl4NUm.js"),r=require("./index-BMvV5qga.js"),C=require("./chain-DBb0uF1j.js");class l{constructor(e,t,s,n){c(this,"network");c(this,"chain");c(this,"rpc");c(this,"contracts");c(this,"tokenBridge");c(this,"translator");this.network=e,this.chain=t,this.rpc=s,this.contracts=n;const a=this.contracts.tokenBridge;if(!a)throw new Error(`Wormhole Token Bridge contract for domain ${t} not found`);if(this.tokenBridge=a,this.translator=this.contracts.translator,this.translator!==void 0&&this.translator==="")throw new Error("Translator address may be undefined but not empty string")}static async fromRpc(e,t){const[s,n]=await i.CosmwasmPlatform.chainFromRpc(e),a=t[n];if(a.network!==s)throw new Error(`Network mismatch: ${a.network} != ${s}`);return new l(s,n,e,t[n].contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch{}return!1}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch{}return!1}async getWrappedAsset(e){if(e.chain===this.chain)throw new Error(`Expected foreign chain, got ${e.chain}`);if(r.isNative(e.address))throw new Error("Native asset cannot be a wrapped asset");const t=r.b64.encode(e.address.toUniversalAddress().toUint8Array()),{address:s}=await this.rpc.queryContractSmart(this.tokenBridge,{wrapped_registry:{chain:r.toChainId(e.chain),address:t}});return r.toNative(this.chain,s)}async getOriginalAsset(e){let t=new i.CosmwasmAddress(e);t.denomType==="factory"&&(t=i.Gateway.factoryToCw20(t));const s=await this.rpc.queryContractSmart(t.toString(),{wrapped_asset_info:{}}),n=r.toChain(s.asset_chain),a=r.b64.decode(s.asset_address);return{chain:n,address:new r.UniversalAddress(new Uint8Array(a))}}async isTransferCompleted(e){const t=r.b64.encode(r.serialize(e));return(await this.rpc.queryContractSmart(this.tokenBridge,{is_vaa_redeemed:{vaa:t}})).is_redeemed}async*createAttestation(e,t){if(!t)throw new Error("Payer required to create attestation");const s=new i.CosmwasmAddress(e).toString(),n=new i.CosmwasmAddress(t).toString(),a=0,w=r.isNative(e)?{native_token:{denom:i.CosmwasmPlatform.getNativeDenom(this.network,this.chain)}}:{token:{contract_addr:s}};yield this.createUnsignedTx({msgs:[o.buildExecuteMsg(n,this.tokenBridge,{create_asset_meta:{asset_info:w,nonce:a}})],fee:o.computeFee(this.network,this.chain),memo:"Wormhole - Create Attestation"},"TokenBridge.createAttestation")}async*submitAttestation(e,t){if(!t)throw new Error("Payer required to submit attestation");const s=new i.CosmwasmAddress(t).toString();yield this.createUnsignedTx({msgs:[o.buildExecuteMsg(s,this.tokenBridge,{submit_vaa:{data:r.serialize(e)}})],fee:o.computeFee(this.network,this.chain),memo:"Wormhole - Submit Attestation"},"TokenBridge.submitAttestation")}async*transfer(e,t,s,n,a){const w=Math.round(Math.random()*1e5),u="0",k=r.toChainId(t.chain),A=r.b64.encode(t.address.toUniversalAddress().toUint8Array()),T=i.CosmwasmPlatform.getNativeDenom(this.network,this.chain),f=r.isNative(s);let d=f?T:s.toString();d.startsWith("factory")&&(d=i.Gateway.factoryToCw20(new i.CosmwasmAddress(d)).toString());const g=new i.CosmwasmAddress(e).toString(),p=m=>{const y={asset:{amount:n.toString(),info:m},recipient_chain:k,recipient:A,fee:u,nonce:w};return a?{initiate_transfer_with_payload:{...y,payload:r.b64.encode(a)}}:{initiate_transfer:y}};if(f){const m=[o.buildExecuteMsg(g,this.tokenBridge,{deposit_tokens:{}},[{amount:n.toString(),denom:d}]),o.buildExecuteMsg(g,this.tokenBridge,p({native_token:{denom:d}}))];yield this.createUnsignedTx({msgs:m,fee:o.computeFee(this.network,this.chain),memo:"Wormhole - Initiate Native Transfer"},"TokenBridge.transferNative")}else{const m=[o.buildExecuteMsg(g,d,{increase_allowance:{spender:this.tokenBridge,amount:n.toString(),expires:{never:{}}}}),o.buildExecuteMsg(g,this.tokenBridge,p({token:{contract_addr:d}}),[{amount:n.toString(),denom:d}])];yield this.createUnsignedTx({msgs:m,fee:o.computeFee(this.network,this.chain),memo:"Wormhole - Initiate Transfer"},"TokenBridge.transfer")}}async*redeem(e,t,s=!0){const n=r.b64.encode(r.serialize(t)),a=new i.CosmwasmAddress(e).toString(),u=this.translator&&new i.CosmwasmAddress(this.translator).toUniversalAddress().equals(t.payload.to.address)?o.buildExecuteMsg(a,this.translator,{complete_transfer_and_convert:{vaa:n}}):o.buildExecuteMsg(a,this.tokenBridge,{submit_vaa:{data:n}});yield this.createUnsignedTx({msgs:[u],fee:o.computeFee(this.network,this.chain),memo:"Wormhole - Complete Transfer"},"TokenBridge.redeem")}async parseTransactionDetails(e){throw new Error("Not implemented")}async getWrappedNative(){return r.toNative(this.chain,i.CosmwasmPlatform.getNativeDenom(this.network,this.chain))}createUnsignedTx(e,t,s=!1){return new o.CosmwasmUnsignedTransaction(e,this.network,this.chain,t,s)}}C.registerProtocol(i._platform,"TokenBridge",l);exports.CosmwasmTokenBridge=l;
